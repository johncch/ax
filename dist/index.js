var h=Object.defineProperty;var a=(u,e)=>h(u,"name",{value:e,configurable:!0});import{R as p,A as o,g,s as l,d,l as c,a as f,i as w,b as k}from"./consoleWriter-CtNNCSna.js";import{C,I as D,L as F,W as P,c as j}from"./consoleWriter-CtNNCSna.js";import*as m from"zod/v4";import"@anthropic-ai/sdk";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:fs/promises";import"node:path";import"chalk";import"node:readline";class v{static{a(this,"Axle")}provider;stats={in:0,out:0};variables={};recorder=new p;constructor(e){if(Object.entries(e).length!==1)throw new o("Must have exactly one config");try{const r=Object.keys(e)[0],t=e[r];this.provider=g(r,t)}catch(r){throw r instanceof o?r:new o("Failed to initialize provider",{code:"PROVIDER_INIT_ERROR",cause:r instanceof Error?r:new Error(String(r))})}}addWriter(e){this.recorder.subscribe(e)}async execute(...e){try{let r;return r=await l(...e).execute({provider:this.provider,variables:this.variables,stats:this.stats,recorder:this.recorder}),r}catch(r){const t=r instanceof o?r:new o("Execution failed",{cause:r instanceof Error?r:new Error(String(r))});return this.recorder.error?.log(t),{response:null,error:t,success:!1}}}async executeDAG(e,r={},t){try{return await d(e,t).execute({provider:this.provider,variables:{...this.variables,...r},stats:this.stats,recorder:this.recorder})}catch(s){const n=s instanceof o?s:new o("DAG execution failed",{cause:s instanceof Error?s:new Error(String(s))});return this.recorder.error?.log(n),{response:null,error:n,success:!1}}}get logs(){return this.recorder.getLogs()}static async loadFileContent(e,r){return r==="utf-8"?c(e,"utf-8"):r==="base64"?c(e,"base64"):c(e)}}class i extends f{static{a(this,"ChainOfThought")}constructor(e,r){super(e,r)}static with(e,r){if(!r)return new i(e,{response:m.string()});if(w(r))return new i(e,r);{const t=k(r);return new i(e,t)}}createInstructions(e=""){return super.createInstructions(`Let's think step by step. Use <thinking></thinking> tags to show your reasoning and thought process.

`)}finalize(e,r={}){const t=super.finalize(e,r),s=this.parseTaggedSections(e);let n="thinking";return"thinking"in s.tags||("think"in s.tags?(n="think",r.recorder?.warn?.log("No <thinking> section found in the response but found <think> instead. This may be a limitation of the model or prompt.")):r.recorder?.warn?.log("No <thinking> section found in the response. Please ensure your response includes a <thinking> tag.")),{...t,thinking:s.tags[n]||""}}}export{v as Axle,i as ChainOfThought,C as ConsoleWriter,D as Instruct,F as LogLevel,P as WriteOutputTask,j as concurrentWorkflow,d as dagWorkflow,l as serialWorkflow};
