#!/usr/bin/env node
var M=Object.defineProperty;var r=(e,t)=>M(e,"name",{value:t,configurable:!0});import{Command as W}from"@commander-js/extra-typings";import{glob as v}from"glob";import{readFile as h,writeFile as E,access as F,mkdir as _,appendFile as G}from"node:fs/promises";import{resolve as I,dirname as X}from"node:path";import k from"chalk";import H from"spinnies";import{randomUUID as N}from"node:crypto";import K from"@anthropic-ai/sdk";import Y from"openai";import U from"yaml";async function D(e,t,s="File"){let n=null,i="";if(e)try{i=I(e),n=await h(i,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const c of t.formats)try{i=I(t.name+"."+c),n=await h(i,{encoding:"utf-8"});break}catch{continue}if(n===null)throw new Error(`${s} not found, see --help for details`)}return{content:n,format:i.split(".").pop()??""}}r(D,"loadFile");function z(e,t){e=e.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,n=e.match(s);if(n){let i="";return n.groups?.asterisks.length==1?i+=t.fileNameStem:i+=t.directoryPath+t.fileNameStem,n.groups?.extension?i+=n.groups.extension:i+=t.fileExtension,e.replace(n[0],i)}return e}r(z,"replaceFilePattern");function Q(e){const t=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=e.match(t);return s&&s.length>0&&s.groups?{absolutePath:e,directoryPath:e.replace(s[0],""),fileExtension:s.groups.extension,fileNameStem:s.groups.name,fullFileName:s[0]}:null}r(Q,"pathToComponents");async function V(e,t="."){try{return(await v(`${t}/${e}.*`)).length>0}catch{return!1}}r(V,"fileExists");async function R(e){const t=X(e);try{await F(t)}catch{await _(t),await R(t)}}r(R,"ensureDirectoryExistence");async function Z(e,t){await R(e),await E(e,t)}r(Z,"writeFileWithDirectories");function m(e){return Array.isArray(e)?e:[e]}r(m,"arrayify");function y(e){return typeof e=="string"?e:JSON.stringify(e,null,2)}r(y,"stringify");function x(e){return e.slice(0,8)}r(x,"friendly");const C="./logs/";class ee{static{r(this,"Writer")}time;constructor(t){this.time=t}get filename(){return`${C}${this.time}.log`}async setup(){try{await F(C)}catch{await _(C)}await E(this.filename,`AXLE: New run at ${this.time}
`)}async write(t){t=`${new Date().toISOString()}> ${t}
`,await G(this.filename,t)}}class te{static{r(this,"Logger")}instanceId=new Date().toISOString();spinnies=new H({color:"white",succeedColor:"white"});opts={debug:!1};writer=null;async initWriter(){this.writer=new ee(new Date().toISOString()),await this.writer.setup()}setOptions(t){this.opts={debug:t.debug??!1}}get progress(){return{add:r((t,s)=>{this.spinnies.add(t,{text:s}),this.writer?.write(s)},"add"),update:r((t,s)=>{this.spinnies.update(t,{text:s}),this.writer?.write(s)},"update"),succeed:r((t,s)=>{this.spinnies.succeed(t,{text:s}),this.writer?.write(s)},"succeed"),fail:r((t,s)=>{this.spinnies.fail(t,{text:s}),this.writer?.write(s)},"fail")}}get info(){return{group(t){const s=y(t);console.log(`
${k.blue("==>")} ${k.whiteBright.bold(s)}`),this.writer?.write(s)},log:r(t=>{const s=y(t);console.log(y(t)),this.writer?.write(s)},"log")}}get debug(){const t=this.opts;return{group(s){const n=y(s);t.debug&&console.log(`
${k.gray("==>")} Debug: ${n}`),this.writer?.write(n)},log:r(s=>{const n=y(s);t.debug&&console.log(k.gray(n)),this.writer?.write(n)},"log")}}}const o=new te;var u=(e=>(e[e.Stop=0]="Stop",e[e.Length=1]="Length",e[e.FunctionCall=2]="FunctionCall",e[e.Error=3]="Error",e))(u||{});class se{static{r(this,"Chat")}system;messages=[];addSystem(t){this.system=t}addUser(t){this.messages.push({role:"user",content:t})}addAssistant(t){this.messages.push({role:"assistant",content:t})}toOpenAI(){return[{role:"system",content:this.system},...this.messages]}toAnthropic(){return{system:this.system,messages:this.messages}}toString(){return JSON.stringify({system:this.system,messages:this.messages})}}async function ne(e,t){try{const s=await h(t.name,"utf-8");e=e.replace(t.pattern,s)}catch(s){console.error(s)}return e}r(ne,"fileReplacer");async function oe(e,t){try{const s=m(t.name);let n="";for(const i of s){const c=await v(i);o.debug.log(`many-files parser. For glob "${i}", found ${c.length} files.`);const a=await Promise.all(c.map(async f=>{const p=await h(f,"utf-8");return f+`:
`+p}));n+=a.join(`
`)}e=e.replace(t.pattern,n)}catch(s){console.error(s)}return e}r(oe,"manyFilesReplacer");async function T(e,t,s={}){return new ie(e,t,s)}r(T,"getAgentCommand");class ie{static{r(this,"AgentJob")}type="agent";id;job;provider;variables;constructor(t,s,n={}){this.id=N(),this.job=t,this.provider=s,this.variables=n}async execute(t,s){const{job:n,provider:i}=this,{steps:c}=n;o.progress.add(this.id,`[${x(this.id)}] Starting job`);const a=new se;let f;for(const[p,g]of c.entries())if(o.progress.update(this.id,`[${x(this.id)}] Processing step ${p+1}: ${g.role}`),g.role==="system")a.addSystem(g.content);else if(g.role==="user"){const b=await this.processInput(g);if(a.addUser(b),t.dryRun){o.debug.log(a);continue}const d=await i.createChatCompletionRequest(a).execute();s.in+=d.usage.in,s.out+=d.usage.out;const q=await this.handleResponse(g,d),{action:$,message:J,error:P}=q;if($=="error"){f=P;break}$=="continue"&&J&&a.addAssistant(J.content)}f?(o.progress.fail(this.id,`[${x(this.id)}] Failed`),console.error(f)):o.progress.succeed(this.id,`[${x(this.id)}] complete`)}async processInput(t){let s=t.content;if(t.replace){const n=m(t.replace);for(const i of n)switch(i.source){case"file":s=await ne(s,i);break;case"many-files":s=await oe(s,i);break;default:s=s.replace(i.pattern,this.variables[i.name])}}return s}async handleResponse(t,s){if(s.type=="success")switch(s.reason){case u.Stop:return await this.processResponse(t,s.message.content??""),{action:"continue",message:s.message};case u.Length:return{action:"error",message:s.message,error:new Error("AXIS: Incomplete model output due to `max_tokens` parameter or token limit")};case u.FunctionCall:default:return{action:"error",message:s.message,error:new Error("AXIS: Unspecified error")}}return{action:"error",error:new Error("Failed to get response from AI provider")}}async processResponse(t,s){const n=m(t.response??[]);for(const i of n)if(i.action==="write-to-disk"){const c=i.output,a=z(c,this.variables.file);await Z(a,s)}else i.action==="save-to-variables"?this.variables[i.output]=s:o.debug?.log("No post action to take")}}async function re(e,t,s){const n=new ae(e,t);return await n.setup(s),n}r(re,"getBatchCommand");class ae{static{r(this,"BatchCommand")}id;job;provider;runs=[];constructor(t,s){this.id=N(),this.job=t,this.provider=s}async setup(t){if(!this.job.batch)throw new Error("Batch job is missing batch field");const s=m(this.job.batch);for(const n of s)if(n.type==="files"){const i=n.input,c=await v(i,{withFileTypes:!0});for(const a of c){const f=a.fullpath(),p=Q(f);if(!await ce(n["skip-condition"],p)){const w={variables:{content:await h(f,"utf-8"),file:p},job:this.job};this.runs.push(w)}}}}async execute(t,s){const n=[],i=[];if(this.runs.length==0)return Promise.resolve("No runs to execute.").then(()=>{o.info.log("No runs to execute")});let c=0;o.progress.add(this.id,`Working on 0/${this.runs.length}`);for(let a=0;a<this.runs.length;a++){const f=this.runs[a],p=new Promise(async(g,b)=>{const w=await T(f.job,this.provider,f.variables);try{await w.execute(t,s),g()}catch(d){console.error(d),b()}finally{c+=1,o.progress.add(this.id,`Working on ${c}/${this.runs.length}`)}});n.push(p),i.push(p),i.length>=5&&(await Promise.all(i),i.length=0)}return Promise.all(n).then(()=>{o.progress.succeed(this.id,`All jobs (${this.runs.length}) completed`)})}}async function ce(e,t){if(e){let s=m(e);for(const n of s)if(n.folder&&n.contains&&n.contains==="fileNameStem"&&t)return await V(t.fileNameStem,n.folder)}return!1}r(ce,"processSkipRules");class ue{static{r(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(t,s){this.model=t??"claude-3-5-sonnet-20240620",this.client=new K({apiKey:s.providers.anthropic["api-key"]})}createChatCompletionRequest(t){return new le(this.client,this.model,t)}}class le{static{r(this,"AnthropicChatRequest")}chat;client;model;constructor(t,s,n){this.client=t,this.model=s,this.chat=n}async execute(){const t={model:this.model,...this.chat.toAnthropic(),max_tokens:fe(this.model)};o.debug.log(t);let s;try{const n=await this.client.messages.create(t);s=ge(n)}catch(n){s={type:"error",error:{type:n.type??"Undetermined",message:n.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:n}}return o.debug.log(s),s}}function fe(e){switch(e){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}r(fe,"getMaxTokens");function pe(e){switch(e){case"max_tokens":return u.Length;case"end_turn":return u.Stop;case"stop_sequence":return u.Stop;case"tool_use":return u.FunctionCall;default:return u.Error}}r(pe,"getStopReason$1");function ge(e){if(e.type=="message"){const t=e.content[0];if(t.type=="text"&&e.stop_reason)return{type:"success",id:e.id,model:e.model,reason:pe(e.stop_reason),message:{role:e.role,content:t.text},usage:{in:e.usage.input_tokens,out:e.usage.output_tokens},raw:e}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from Anthropic"},usage:{in:e.usage.input_tokens,out:e.usage.output_tokens},raw:e}}r(ge,"translate$1");class de{static{r(this,"OpenAIProvider")}name="OpenAI";client;model;constructor(t,s,n){this.model=t,this.client=new Y({apiKey:s.providers.openai["api-key"]})}createChatCompletionRequest(t){return new he(this.client,this.model,t)}}class he{static{r(this,"OpenAIRequest")}chat;openai;model;constructor(t,s,n){this.openai=t,this.model=s||"gpt-4o",this.chat=n}async execute(){const t={model:this.model,messages:this.chat.toOpenAI()};o.debug.log(t);let s;try{const n=await this.openai.chat.completions.create(t);s=ye(n)}catch(n){s={type:"error",error:{type:n.type??"Undetermined",message:n.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:n}}return o.debug.log(s),s}}function me(e){switch(e){case"length":return u.Length;case"stop":return u.Stop;case"function_call":return u.FunctionCall;default:return u.Error}}r(me,"getStopReason");function ye(e){if(e.choices.length>0){const t=e.choices[0];return{type:"success",id:e.id,model:e.model,reason:me(t.finish_reason),message:{content:t.message.content??"",role:t.message.role},usage:{in:e.usage?.prompt_tokens??0,out:e.usage?.completion_tokens??0},raw:e}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:e.usage?.prompt_tokens??0,out:e.usage?.completion_tokens??0},raw:e}}r(ye,"translate");function be(e,t,s){return e.engine=="openai"?new de(e.model,t,s):e.engine=="anthropic"?new ue(e.model,t):null}r(be,"getEngine");const we="ax.config",ke=["yaml","yml","json"];async function xe(e,t){const{content:s,format:n}=await D(e,{name:we,formats:ke},"Config File");let i=null;if(n==="json")i=JSON.parse(s);else if(n==="yaml"||n==="yml")i=U.parse(s);else throw new Error("Invalid config file format");if(o.debug.group("The Config Object"),o.debug.log(i),Ae(i))return i;throw new Error("The config file is not valid")}r(xe,"getConfig");function Ae(e){return e&&typeof e=="object"&&"providers"in e&&typeof e.providers=="object"&&Object.keys(e.providers).length>0&&Object.entries(e.providers).every(([t,s])=>typeof t=="string"&&s&&typeof s=="object"&&"api-key"in s&&typeof s["api-key"]=="string"&&(!("model"in s)||typeof s.model=="string"))}r(Ae,"isConfig");const Se="ax.job",ve=["yaml","yml","json"];async function Ce(e,t){const{content:s,format:n}=await D(e,{name:Se,formats:ve},"Job File");let i=null;if(n==="json")i=JSON.parse(s);else if(n==="yaml"||n==="yml")i=U.parse(s);else throw new Error("Invalid job file format");if(o.debug?.group("The Job Object"),o.debug?.log(i),Oe(i))return i;throw new Error("The job file is not valid")}r(Ce,"getJob");function Oe(e){if(!e||typeof e!="object")return o.debug.log("isJobConfig: obj is not an object"),!1;if(!je(e.using))return o.debug.log("isJobConfig: using property is invalid"),!1;if(typeof e.jobs!="object")return o.debug.log("isJobConfig: jobs is not an object"),!1;for(const t of Object.values(e.jobs))if(!B(t))return o.debug.log("isJobConfig: invalid job in jobs object"),!1;return!0}r(Oe,"isJobConfig");function je(e){return!e||typeof e!="object"?(o.debug.log("isUsing: obj is not an object"),!1):e.engine!=="openai"&&e.engine!=="anthropic"?(o.debug.log("isUsing: invalid engine"),!1):e.model!==void 0&&typeof e.model!="string"?(o.debug.log("isUsing: model is defined but not a string"),!1):!0}r(je,"isUsing");function B(e){if(!e||typeof e!="object")return o.debug.log("isJob: obj is not an object"),!1;if(e.type!=="agent"&&e.type!=="batch")return o.debug.log("isJob: invalid job type"),!1;if(!Array.isArray(e.steps))return o.debug.log("isJob: steps is not an array"),!1;for(const t of e.steps)if(!Ee(t))return o.debug.log("isJob: invalid step in steps array"),!1;return!0}r(B,"isJob");function $e(e){return!e||typeof e!="object"?(o.debug.log("isSkipOptions: obj is not an object"),!1):typeof e.folder!="string"?(o.debug.log("isSkipOptions: folder is not a string"),!1):typeof e.contains!="string"?(o.debug.log("isSkipOptions: contains is not a string"),!1):!0}r($e,"isSkipOptions");function Je(e){if(!B(e))return o.debug.log("isBatchJob: obj is not a valid Job"),!1;if(e=e,e.type!=="batch")return o.debug.log("isBatchJob: job type is not 'batch'"),!1;if(!Array.isArray(e.batch))return o.debug.log("isBatchJob: batch is not an array"),!1;for(const t of e.batch){if(t.type!=="files")return o.debug.log("isBatchJob: batch item type is not 'files'"),!1;if(typeof t.input!="string")return o.debug.log("isBatchJob: input is not a string"),!1;if(t["skip-condition"]!==void 0){if(!Array.isArray(t["skip-condition"]))return o.debug.log("isBatchJob: skip-condition is not an array"),!1;for(const s of t["skip-condition"])if(!$e(s))return o.debug.log("isBatchJob: invalid skip-condition"),!1}}return!0}r(Je,"isBatchJob");function Ee(e){return!e||typeof e!="object"?(o.debug.log("isStep: obj is not an object"),!1):e.role!=="system"&&e.role!=="user"?(o.debug.log("isStep: invalid step type"),!1):typeof e.content!="string"?(o.debug.log("isStep: message is not a string"),!1):e.response!==void 0&&typeof e.response!="object"?(o.debug.log("isStep: response property is missing"),!1):e.replace!==void 0&&typeof e.replace!="object"?(o.debug.log("isStep: replace is defined but not an object"),!1):!0}r(Ee,"isStep");const A=new W().name("ax").description("A CLI tool for running AI jobs").version("1.0.0").option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("--no-log","Do not write the output to a log file").option("-d, --debug","Print additional debug information");A.parse();const l=A.opts();o.setOptions(l),l.log&&await o.initWriter(),l.debug&&(o.debug?.group("Options"),o.debug?.log(l));let L,O;try{L=await xe(l.config??null,l),O=await Ce(l.job??null,l)}catch(e){o.debug?.log(e.stack),console.error(`${e.stack}`),A.outputHelp(),process.exit(1)}const j=be(O.using,L,l);j||(console.error("AI Provider is not valid. Please check your job file."),A.outputHelp(),process.exit(1)),o.info.group("All systems operational. Running job...");const Fe=Date.now();l.dryRun&&o.info.log("Dry run mode enabled. No API calls will be made.");const S={in:0,out:0};for(const[e,t]of Object.entries(O.jobs))o.info.group(`Executing "${e}"`),Je(t)?await(await re(t,j,l)).execute(l,S):await(await T(t,j)).execute(l,S);o.info.group("Usage"),o.info.log(`Total run time: ${Date.now()-Fe}ms`),o.info.log(`Input tokens: ${S.in} `),o.info.log(`Output tokens: ${S.out} `),o.info.group("Complete. Goodbye");
