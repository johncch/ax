#!/usr/bin/env node
var q=Object.defineProperty;var r=(e,t)=>q(e,"name",{value:t,configurable:!0});import{Command as L}from"@commander-js/extra-typings";import{glob as $}from"glob";import{readFile as h,writeFile as C,access as I,mkdir as E,appendFile as W}from"node:fs/promises";import{resolve as F}from"node:path";import M from"path";import m from"chalk";import G from"spinnies";import{randomUUID as N}from"node:crypto";import H from"openai";import P from"yaml";async function R(e,t,o="File"){let i=null,s="";if(e)try{s=F(e),i=await h(s,{encoding:"utf-8"})}catch{throw new Error(`${o} not found, see --help for details`)}else{for(const c of t.formats)try{s=F(t.name+"."+c),i=await h(s,{encoding:"utf-8"});break}catch{continue}if(i===null)throw new Error(`${o} not found, see --help for details`)}return{content:i,format:s.split(".").pop()??""}}r(R,"loadFile");function K(e,t){e=e.replace("**/*","**");const o=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,i=e.match(o);if(i){let s="";return i.groups?.asterisks.length==1?s+=t.fileNameStem:s+=t.directoryPath+t.fileNameStem,i.groups?.extension?s+=i.groups.extension:s+=t.fileExtension,e.replace(i[0],s)}return e}r(K,"replaceFilePattern");function X(e){const t=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,o=e.match(t);return o&&o.length>0&&o.groups?{absolutePath:e,directoryPath:e.replace(o[0],""),fileExtension:o.groups.extension,fileNameStem:o.groups.name,fullFileName:o[0]}:null}r(X,"pathToComponents");async function Y(e,t="."){try{return(await $(`${t}/${e}.*`)).length>0}catch{return!1}}r(Y,"fileExists");async function D(e){const t=M.dirname(e);try{await I(t)}catch{await E(t),await D(t)}}r(D,"ensureDirectoryExistence");async function z(e,t){await D(e),await C(e,t)}r(z,"writeFileWithDirectories");function b(e){return Array.isArray(e)?e:[e]}r(b,"arrayify");function g(e){return typeof e=="string"?e:JSON.stringify(e,null,2)}r(g,"stringify");function k(e){return e.slice(0,8)}r(k,"friendly");const x="./logs/";class Q{static{r(this,"Writer")}time;constructor(t){this.time=t}get filename(){return`${x}${this.time}.log`}async setup(){try{await I(x)}catch{await E(x)}await C(this.filename,`AXLE: New run at ${this.time}
`)}async write(t){t=`${new Date().toISOString()}> ${t}
`,await W(this.filename,t)}}class V{static{r(this,"Logger")}instanceId=new Date().toISOString();spinnies=new G({color:"white",succeedColor:"white"});opts={debug:!1};writer=null;async initWriter(){this.writer=new Q(new Date().toISOString()),await this.writer.setup()}setOptions(t){this.opts={debug:t.debug??!1}}get progress(){return{add:r((t,o)=>{this.spinnies.add(t,{text:o}),this.writer?.write(o)},"add"),update:r((t,o)=>{this.spinnies.update(t,{text:o}),this.writer?.write(o)},"update"),succeed:r((t,o)=>{this.spinnies.succeed(t,{text:o}),this.writer?.write(o)},"succeed"),fail:r((t,o)=>{this.spinnies.fail(t,{text:o}),this.writer?.write(o)},"fail")}}get info(){return{group(t){const o=g(t);console.log(`
${m.blue("==>")} ${m.whiteBright.bold(o)}`),this.writer?.write(o)},log:r(t=>{const o=g(t);console.log(g(t)),this.writer?.write(o)},"log")}}get debug(){const t=this.opts;return{group(o){const i=g(o);t.debug&&console.log(`
${m.gray("==>")} Debug: ${i}`),this.writer?.write(i)},log:r(o=>{const i=g(o);t.debug&&console.log(m.gray(i)),this.writer?.write(i)},"log")}}}const n=new V;async function _(e,t,o={}){return new Z(e,t,o)}r(_,"getAgentCommand");class Z{static{r(this,"AgentJob")}type="agent";id;job;provider;variables;constructor(t,o,i={}){this.id=N(),this.job=t,this.provider=o,this.variables=i}async execute(t,o){const{job:i,provider:s}=this,{steps:c}=i;n.progress.add(this.id,`[${k(this.id)}] Starting job`);const a=[];for(const[f,l]of c.entries())if(n.progress.update(this.id,`[${k(this.id)}] Processing step ${f}: ${l.role}`),l.role==="system")a.push({role:l.role,content:l.content});else if(l.role==="user"){const d=await this.processInput(l);if(a.push({role:l.role,content:d}),t.dryRun)continue;const p=await s.createChatCompletionRequest(a).execute();o.in+=p.usage.in,o.out+=p.usage.out;const v=await this.handleResponse(l,p),{action:A,message:O,error:U}=v;if(A=="error"){console.error(U);break}A=="continue"&&O&&a.push(O)}n.progress.succeed(this.id,`[${k(this.id)}] complete`)}async processInput(t){let o=t.content;if(t.replace){const i=b(t.replace);for(const s of i){const c=s.source??"variables";if(c==="variables")o=o.replace(s.pattern,this.variables[s.name]);else if(c==="file")try{const a=await h(s.name,"utf-8");o=o.replace(s.pattern,a)}catch(a){console.error(a)}}}return o}async handleResponse(t,o){if(o.type=="success")switch(o.reason){case"stop":return await this.processResponse(t,o.message.content??""),{action:"continue",message:o.message};case"length":return{action:"error",message:o.message,error:new Error("Incomplete model output due to `max_tokens` parameter or token limit")};case"function_call":default:return{action:"error",message:o.message,error:new Error("Incomplete model output due to `max_tokens` parameter or token limit")}}return{action:"error",error:new Error("Failed to get response from AI provider")}}async processResponse(t,o){const i=b(t.response??[]);for(const s of i)if(s.action==="write-to-disk"){const c=s.output,a=K(c,this.variables.file);await z(a,o)}else s.action==="save-to-variables"?this.variables[s.output]=o:n.debug?.log("No post action to take")}}async function ee(e,t,o){const i=new te(e,t);return await i.setup(o),i}r(ee,"getBatchCommand");class te{static{r(this,"BatchCommand")}id;job;provider;runs=[];constructor(t,o){this.id=N(),this.job=t,this.provider=o}async setup(t){if(!this.job.batch)throw new Error("Batch job is missing batch field");const o=b(this.job.batch);for(const i of o)if(i.type==="files"){const s=i.input,c=await $(s,{withFileTypes:!0});for(const a of c){const f=a.fullpath(),l=X(f);if(!await oe(i["skip-condition"],l)){const p={variables:{content:await h(f,"utf-8"),file:l},job:this.job};this.runs.push(p)}}}}async execute(t,o){const i=[],s=[];if(this.runs.length==0)return Promise.resolve("No runs to execute.").then(()=>{n.info.log("No runs to execute")});let c=0;n.progress.add(this.id,`Working on 0/${this.runs.length}`);for(let a=0;a<this.runs.length;a++){const f=this.runs[a],l=new Promise(async(d,w)=>{const p=await _(f.job,this.provider,f.variables);try{await p.execute(t,o),d()}catch(v){console.error(v),w()}finally{c+=1,n.progress.add(this.id,`Working on ${c}/${this.runs.length}`)}});i.push(l),s.push(l),s.length>=5&&(await Promise.all(s),s.length=0)}return Promise.all(i).then(()=>{n.progress.succeed(this.id,`All jobs (${this.runs.length}) completed`)})}}async function oe(e,t){if(e){let o=b(e);for(const i of o)if(i.folder&&i.contains&&i.contains==="fileNameStem"&&t)return await Y(t.fileNameStem,i.folder)}return!1}r(oe,"processSkipRules");class ie{static{r(this,"OpenAIProvider")}name="OpenAI";openai;model;constructor(t,o,i){this.model=t,this.openai=new H({apiKey:o.providers.openai["api-key"]})}createChatCompletionRequest(t){return new ne(this.openai,this.model,t)}}class ne{static{r(this,"OpenAIRequest")}messages={};openai;model;constructor(t,o,i){this.openai=t,this.model=o||"gpt-4o",this.messages=i}async execute(){const t={model:this.model,messages:this.messages};n.debug.log(t);const o=await this.openai.chat.completions.create(t);return n.debug.log(o),se(o)}}function se(e){const t=e.choices[0];return{type:"success",id:e.id,model:e.model,reason:t.finish_reason,message:{content:t.message.content,role:t.message.role},usage:{in:e.usage?.prompt_tokens??0,out:e.usage?.completion_tokens??0},raw:e}}r(se,"translate");function re(e,t,o){return e.engine=="openai"?new ie(e.model,t,o):null}r(re,"getEngine");const ae="ax.config",ce=["yaml","yml","json"];async function le(e,t){const{content:o,format:i}=await R(e,{name:ae,formats:ce},"Config File");let s=null;if(i==="json")s=JSON.parse(o);else if(i==="yaml"||i==="yml")s=P.parse(o);else throw new Error("Invalid config file format");if(n.debug.group("The Config Object"),n.debug.log(s),ue(s))return s;throw new Error("The config file is not valid")}r(le,"getConfig");function ue(e){return e&&typeof e=="object"&&"providers"in e&&typeof e.providers=="object"&&Object.keys(e.providers).length>0&&Object.entries(e.providers).every(([t,o])=>typeof t=="string"&&o&&typeof o=="object"&&"api-key"in o&&typeof o["api-key"]=="string"&&(!("model"in o)||typeof o.model=="string"))}r(ue,"isConfig");const fe="ax.job",pe=["yaml","yml","json"];async function ge(e,t){const{content:o,format:i}=await R(e,{name:fe,formats:pe},"Job File");let s=null;if(i==="json")s=JSON.parse(o);else if(i==="yaml"||i==="yml")s=P.parse(o);else throw new Error("Invalid job file format");if(n.debug?.group("The Job Object"),n.debug?.log(s),de(s))return s;throw new Error("The job file is not valid")}r(ge,"getJob");function de(e){if(!e||typeof e!="object")return n.debug?.log("isJobConfig: obj is not an object"),!1;if(!he(e.using))return n.debug?.log("isJobConfig: using property is invalid"),!1;if(typeof e.jobs!="object")return n.debug?.log("isJobConfig: jobs is not an object"),!1;for(const t of Object.values(e.jobs))if(!B(t))return n.debug?.log("isJobConfig: invalid job in jobs object"),!1;return!0}r(de,"isJobConfig");function he(e){return!e||typeof e!="object"?(n.debug?.log("isUsing: obj is not an object"),!1):e.engine!=="openai"&&e.engine!=="anthropic"?(n.debug?.log("isUsing: invalid engine"),!1):e.model!==void 0&&typeof e.model!="string"?(n.debug?.log("isUsing: model is defined but not a string"),!1):!0}r(he,"isUsing");function B(e){if(!e||typeof e!="object")return n.debug?.log("isJob: obj is not an object"),!1;if(e.type!=="agent"&&e.type!=="batch")return n.debug?.log("isJob: invalid job type"),!1;if(!Array.isArray(e.steps))return n.debug?.log("isJob: steps is not an array"),!1;for(const t of e.steps)if(!ye(t))return n.debug?.log("isJob: invalid step in steps array"),!1;return!0}r(B,"isJob");function me(e){return!e||typeof e!="object"?(n.debug?.log("isSkipOptions: obj is not an object"),!1):typeof e.folder!="string"?(n.debug?.log("isSkipOptions: folder is not a string"),!1):typeof e.contains!="string"?(n.debug?.log("isSkipOptions: contains is not a string"),!1):!0}r(me,"isSkipOptions");function be(e){if(!B(e))return n.debug?.log("isBatchJob: obj is not a valid Job"),!1;if(e=e,e.type!=="batch")return n.debug?.log("isBatchJob: job type is not 'batch'"),!1;if(!Array.isArray(e.batch))return n.debug?.log("isBatchJob: batch is not an array"),!1;for(const t of e.batch){if(t.type!=="files")return n.debug?.log("isBatchJob: batch item type is not 'files'"),!1;if(typeof t.input!="string")return n.debug?.log("isBatchJob: input is not a string"),!1;if(t["skip-condition"]!==void 0){if(!Array.isArray(t["skip-condition"]))return n.debug?.log("isBatchJob: skip-condition is not an array"),!1;for(const o of t["skip-condition"])if(!me(o))return n.debug?.log("isBatchJob: invalid skip-condition"),!1}}return!0}r(be,"isBatchJob");function ye(e){return!e||typeof e!="object"?(n.debug?.log("isStep: obj is not an object"),!1):e.role!=="system"&&e.role!=="user"?(n.debug?.log("isStep: invalid step type"),!1):typeof e.content!="string"?(n.debug?.log("isStep: message is not a string"),!1):e.response!==void 0&&typeof e.response!="object"?(n.debug?.log("isStep: response property is missing"),!1):e.replace!==void 0&&typeof e.replace!="object"?(n.debug?.log("isStep: replace is defined but not an object"),!1):!0}r(ye,"isStep");const S=new L().version("1.0.0").option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("--no-log","Do not write the output to a log file").option("-d, --debug","Print additional debug information");S.parse();const u=S.opts();n.setOptions(u),u.log&&await n.initWriter(),u.debug&&(n.debug?.group("Options"),n.debug?.log(u));let T,j;try{T=await le(u.config??null,u),j=await ge(u.job??null,u)}catch(e){console.error(`${e}`),console.error(`${e.stack}`),S.outputHelp(),process.exit(1)}const J=re(j.using,T,u);J||(console.error("AI Provider is not defined. Please check your job file."),process.exit(1)),n.info.group("All systems operational. Running job..."),u.dryRun&&n.info.log("Dry run mode enabled. No API calls will be made.");const y={in:0,out:0};for(const[e,t]of Object.entries(j.jobs))n.info.group(`Executing "${e}"`),be(t)?await(await ee(t,J,u)).execute(u,y):await(await _(t,J)).execute(u,y);n.info.group("Usage"),n.info.log(`Input tokens: ${y.in} `),n.info.log(`Output tokens: ${y.out} `),n.info.group("Complete. Goodbye");
