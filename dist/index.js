#!/usr/bin/env node
var I=Object.defineProperty;var r=(e,t)=>I(e,"name",{value:t,configurable:!0});import{Command as $}from"@commander-js/extra-typings";import{glob as P}from"glob";import d from"chalk";import{readFile as y,writeFile as S,access as _,mkdir as N}from"node:fs/promises";import{resolve as J}from"node:path";import R from"path";import T from"ora";import U from"openai";import A from"yaml";function w(e){return Array.isArray(e)?e:[e]}r(w,"arrayify");class D{static{r(this,"Logger")}opts={verbose:!1,debug:!1};setOptions(t){this.opts={verbose:t.verbose??!1,debug:t.debug??!1}}get info(){return{log(t){typeof t!="string"&&(t=JSON.stringify(t,null,2)),console.log(`
${d.blue("==>")} ${d.whiteBright.bold(t)}`)}}}get verbose(){if(this.opts.verbose)return{log(t){typeof t!="string"&&(t=JSON.stringify(t,null,2)),console.log(`
${d.gray("==>")} Verbose: ${t}`)}}}get debug(){if(this.opts.debug)return{log(t){typeof t!="string"&&(t=JSON.stringify(t,null,2)),console.log(`
${d.gray("==>")} Debug: ${t}`)}}}}const i=new D;async function k(e,t,o="File"){let n=null,s="";if(e)try{s=J(e),n=await y(s,{encoding:"utf-8"})}catch{throw new Error(`${o} not found, see --help for details`)}else{for(const l of t.formats)try{s=J(t.name+"."+l),n=await y(s,{encoding:"utf-8"});break}catch{continue}if(n===null)throw new Error(`${o} not found, see --help for details`)}return{content:n,format:s.split(".").pop()??""}}r(k,"loadFile");function q(e,t){e=e.replace("**/*","**");const o=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,n=e.match(o);if(n){let s="";return n.groups?.asterisks.length==1?s+=t.file.name:s+=t.folders+t.file.name,n.groups?.extension?s+=n.groups.extension:s+=t.file.extension,e.replace(n[0],s)}return e}r(q,"replaceFilePattern");function B(e){const t=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,o=e.match(t);return{path:e,folders:e.replace(o[0],""),file:{full:o[0],name:o.groups.name,extension:o.groups.extension}}}r(B,"pathToComponents");async function O(e){const t=R.dirname(e);try{await _(t)}catch{await O(t),await N(t)}}r(O,"ensureDirectoryExistence");async function L(e,t){await O(e),await S(e,t)}r(L,"writeFileWithDirectories");async function M(e,t,o={}){return new G(e,t,o)}r(M,"getAgentJob");class G{static{r(this,"AgentJob")}type="agent";job;provider;variables;constructor(t,o,n={}){this.job=t,this.provider=o,this.variables=n}async execute(t,o){const{job:n,provider:s}=this,{steps:l}=n,a=[];for(const c of l)if(c.role==="system")a.push({role:c.role,content:c.content});else if(c.role==="user"){const g=this.processInput(c);if(a.push({role:c.role,content:g}),t.dryRun){i.info.log("Dry run mode enabled. Skipping API call.");continue}const f=await s.createChatCompletionRequest(a).execute();o.in+=f.usage.in,o.out+=f.usage.out;const b=await this.handleResponse(c,f),{action:m,message:h,error:F}=b;if(m=="error"){console.error(F);break}m=="continue"&&h&&a.push(h)}}processInput(t){let o=t.content;if(t.replace){const n=w(t.replace);for(const s of n)o=o.replace(s.pattern,this.variables[s.with])}return o}async handleResponse(t,o){if(o.type=="success")switch(o.reason){case"stop":return await this.processResponse(t,o.message.content??""),{action:"continue",message:o.message};case"length":return{action:"error",message:o.message,error:new Error("Incomplete model output due to `max_tokens` parameter or token limit")};case"function_call":default:return{action:"error",message:o.message,error:new Error("Incomplete model output due to `max_tokens` parameter or token limit")}}return{action:"error",error:new Error("Failed to get response from AI provider")}}async processResponse(t,o){const n=w(t.response??[]);for(const s of n)if(s.action==="write-to-disk"){const l=s.output,a=q(l,this.variables.file);await L(a,o)}else i.debug?.log("No post action to take")}}async function W(e,t,o){const n=new H(e,t);return await n.setup(o),n}r(W,"getBatchJob");class H{static{r(this,"BatchJob")}job;provider;runs=[];constructor(t,o){this.job=t,this.provider=o}async setup(t){if(i.verbose?.log("Setting up batch job"),!this.job.batch)throw new Error("Batch job is missing batch field");const o=w(this.job.batch);for(const n of o)if(n.type==="files"){const s=n.input,l=await P(s,{withFileTypes:!0});for(const a of l){const c=a.fullpath(),g=B(c),f={variables:{content:await y(c,"utf-8"),file:g},job:this.job};this.runs.push(f)}}}async execute(t,o){const n=[],s=[];if(this.runs.length==0)return Promise.resolve("No runs to execute.").then(()=>{i.info.log("No runs to execute")});let l=0;const a=T(`Working on 0/${this.runs.length}`).start();for(let c=0;c<this.runs.length;c++){const g=this.runs[c],p=new Promise(async(f,b)=>{const m=await M(g.job,this.provider,g.variables);try{await m.execute(t,o),f()}catch(h){console.error(h),b()}finally{l+=1,a.text=`Working on ${l}/${this.runs.length}`}});n.push(p),s.push(p),s.length>=5&&(await Promise.all(s),s.length=0)}return Promise.all(n).then(()=>{a.succeed(`All jobs (${this.runs.length}) completed`)})}}class K{static{r(this,"OpenAIProvider")}name="OpenAI";openai;model;constructor(t,o,n){this.model=t,this.openai=new U({apiKey:o.providers.openai["api-key"]})}createChatCompletionRequest(t){return new V(this.openai,this.model,t)}}class V{static{r(this,"OpenAIRequest")}messages={};openai;model;constructor(t,o,n){this.openai=t,this.model=o||"gpt-4o",this.messages=n}async execute(){return new Promise(async(o,n)=>{const s=this.messages,l=await this.openai.chat.completions.create({model:this.model,messages:s}),a=Y(l);o(a)})}}function Y(e){const t=e.choices[0];return{type:"success",id:e.id,model:e.model,reason:t.finish_reason,message:{content:t.message.content,role:t.message.role},usage:{in:e.usage?.prompt_tokens??0,out:e.usage?.completion_tokens??0},raw:e}}r(Y,"translate");function z(e,t,o){return e.engine=="openai"?new K(e.model,t,o):null}r(z,"getEngine");const Q="ax.config",X=["yaml","yml","json"];async function Z(e,t){const{content:o,format:n}=await k(e,{name:Q,formats:X},"Config File");let s=null;if(n==="json")s=JSON.parse(o);else if(n==="yaml"||n==="yml")s=A.parse(o);else throw new Error("Invalid config file format");if(i.debug?.log(s),ee(s))return s;throw new Error("The config file is not valid")}r(Z,"getConfig");function ee(e){return e&&typeof e=="object"&&"providers"in e&&typeof e.providers=="object"&&Object.keys(e.providers).length>0&&Object.entries(e.providers).every(([t,o])=>typeof t=="string"&&o&&typeof o=="object"&&"api-key"in o&&typeof o["api-key"]=="string"&&(!("model"in o)||typeof o.model=="string"))}r(ee,"isConfig");const te="ax.job",oe=["yaml","yml","json"];async function ne(e,t){const{content:o,format:n}=await k(e,{name:te,formats:oe},"Job File");let s=null;if(n==="json")s=JSON.parse(o);else if(n==="yaml"||n==="yml")s=A.parse(o);else throw new Error("Invalid job file format");if(i.debug?.log(s),se(s))return s;throw new Error("The job file is not valid")}r(ne,"getJob");function se(e){if(!e||typeof e!="object")return i.debug?.log("isJobConfig: obj is not an object"),!1;if(!ie(e.using))return i.debug?.log("isJobConfig: using property is invalid"),!1;if(typeof e.jobs!="object")return i.debug?.log("isJobConfig: jobs is not an object"),!1;for(const t of Object.values(e.jobs))if(!re(t))return i.debug?.log("isJobConfig: invalid job in jobs object"),!1;return!0}r(se,"isJobConfig");function ie(e){return!e||typeof e!="object"?(i.debug?.log("isUsing: obj is not an object"),!1):e.engine!=="openai"&&e.engine!=="anthropic"?(i.debug?.log("isUsing: invalid engine"),!1):e.model!==void 0&&typeof e.model!="string"?(i.debug?.log("isUsing: model is defined but not a string"),!1):!0}r(ie,"isUsing");function re(e){if(!e||typeof e!="object")return i.debug?.log("isJob: obj is not an object"),!1;if(e.type!=="agent"&&e.type!=="batch")return i.debug?.log("isJob: invalid job type"),!1;if(!Array.isArray(e.steps))return i.debug?.log("isJob: steps is not an array"),!1;for(const t of e.steps)if(!ae(t))return i.debug?.log("isJob: invalid step in steps array"),!1;return!0}r(re,"isJob");function ae(e){return!e||typeof e!="object"?(i.debug?.log("isStep: obj is not an object"),!1):e.role!=="system"&&e.role!=="user"?(i.debug?.log("isStep: invalid step type"),!1):typeof e.content!="string"?(i.debug?.log("isStep: message is not a string"),!1):e.response!==void 0&&typeof e.response!="object"?(i.debug?.log("isStep: response property is missing"),!1):e.replace!==void 0&&typeof e.replace!="object"?(i.debug?.log("isStep: replace is defined but not an object"),!1):!0}r(ae,"isStep");const v=new $().version("1.0.0").option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("-d, --debug","Print additional debug information").option("--verbose","Print out the options",!1);v.parse();const u=v.opts();i.setOptions(u),i.debug?.log(u);let C,x;try{C=await Z(u.config??null,u),x=await ne(u.job??null,u)}catch(e){console.error(`${e}`),v.outputHelp(),process.exit(1)}const E=z(x.using,C,u);E||(console.error("AI Provider is not defined. Please check your job file."),process.exit(1)),i.info.log("All systems operational. Running job...");const j={in:0,out:0};for(const[e,t]of Object.entries(x.jobs))i.info.log(`Executing "${e}"`),t.type=="batch"&&await(await W(t,E,u)).execute(u,j);i.info.log("Usage"),console.log(`Input tokens: ${j.in} `),console.log(`Output tokens: ${j.out} `),i.info.log("Complete. Goodbye");
