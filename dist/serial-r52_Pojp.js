var U=Object.defineProperty;var a=(t,e)=>U(t,"name",{value:e,configurable:!0});import N from"@anthropic-ai/sdk";import q from"openai";import{readFile as M,access as j,constants as H}from"fs/promises";import{glob as _}from"glob";import{readFile as v,writeFile as K,access as J,mkdir as W}from"node:fs/promises";import{resolve as $,dirname as B}from"node:path";function G(t,e){if(typeof t!="object"||t===null)return e&&(e.value="Config: must be a non-null object"),!1;if("openai"in t){const s=t.openai;if(typeof s!="object"||s===null)return e&&(e.value="Config: openai must be an object"),!1;if(typeof s["api-key"]!="string")return e&&(e.value="Config: openai.api-key must be a string"),!1;if("model"in s&&typeof s.model!="string")return e&&(e.value="Config: openai.model must be a string"),!1}if("anthropic"in t){const s=t.anthropic;if(typeof s!="object"||s===null)return e&&(e.value="Config: anthropic must be an object"),!1;if(typeof s["api-key"]!="string")return e&&(e.value="Config: anthropic.api-key must be a string"),!1;if("model"in s&&typeof s.model!="string")return e&&(e.value="Config: anthropic.model must be a string"),!1}if("ollama"in t){const s=t.ollama;if(typeof s!="object"||s===null)return e&&(e.value="Config: ollama must be an object"),!1;if("url"in s&&typeof s.url!="string")return e&&(e.value="Config: ollama.url must be a string"),!1;if("model"in s&&typeof s.model!="string")return e&&(e.value="Config: ollama.model must be a string"),!1}if("brave"in t){const s=t.brave;if(typeof s!="object"||s===null)return e&&(e.value="Config: brave must be an object"),!1;if(typeof s["api-key"]!="string")return e&&(e.value="Config: brave.api-key must be a string"),!1;if("delay"in s&&typeof s.delay!="number")return e&&(e.value="Config: brave.delay must be a number"),!1}return!0}a(G,"isProviderConfig");function L(t){if(!t||typeof t!="object")throw new Error("Not an object");if(!("api-key"in t)||typeof t["api-key"]!="string")throw new Error("Missing or invalid 'api-key'");if(!("model"in t)||typeof t.model!="string")throw new Error("Missing or invalid 'model'")}a(L,"assertIsOpenAIProviderConfig");function z(t){if(!t||typeof t!="object")throw new Error("Not an object");if(!("api-key"in t)||typeof t["api-key"]!="string")throw new Error("Missing or invalid 'api-key'");if(!("model"in t)||typeof t.model!="string")throw new Error("Missing or invalid 'model'")}a(z,"assertIsAnthropicProviderConfig");function V(t){if(!t||typeof t!="object")throw new Error("Not an object");if(!("url"in t)||typeof t.url!="string")throw new Error("Missing or invalid 'url'");if(!("model"in t)||typeof t.model!="string")throw new Error("Missing or invalid 'model'")}a(V,"assertIsOllamaProviderConfig");var d=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(d||{});const X={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},Q=X.CLAUDE_3_5_HAIKU_LATEST;class Y{static{a(this,"AnthropicProvider")}name="Anthropic";client;model;recorder;constructor({config:e,use:s,recorder:n}){const r={"api-key":e["api-key"]||s["api-key"],model:e.model||s.model||Q};try{z(r),this.model=r.model,this.client=new N({apiKey:r["api-key"]}),this.recorder=n}catch(o){throw new Error(`Invalid Anthropic configuration: ${o}`)}}createChatCompletionRequest(e){return new Z({client:this.client,model:this.model,chat:e,recorder:this.recorder})}}class Z{static{a(this,"AnthropicChatRequest")}chat;client;model;recorder;constructor({client:e,model:s,chat:n,recorder:r}){this.client=e,this.model=s,this.chat=n,this.recorder=r}async execute(){const e={model:this.model,...this.chat.toAnthropic(),max_tokens:ee(this.model)};this.recorder?.debug?.log(e);let s;try{const n=await this.client.messages.create(e);s=te(n)}catch(n){s={type:"error",error:{type:n.error.error.type??"Undetermined",message:n.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:n}}return this.recorder?.debug?.log(s),s}}function ee(t){switch(t){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}a(ee,"getMaxTokens");function S(t){switch(t){case"max_tokens":return d.Length;case"end_turn":return d.Stop;case"stop_sequence":return d.Stop;case"tool_use":return d.FunctionCall;default:return d.Error}}a(S,"getStopReason$1");function te(t){const e=S(t.stop_reason);if(e===d.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===d.FunctionCall){const s=t.content[0],n=s.type==="text"?s.text:"",r=t.content.slice(1).map(o=>{if(o.type==="tool_use")return{id:o.id,name:o.name,arguments:o.input}}).filter(o=>o!==null);return{type:"success",id:t.id,model:t.model,reason:d.FunctionCall,message:{role:t.role,content:n,toolCalls:r},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:S(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}a(te,"translate$1");const se="http://localhost:11434";class ne{static{a(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor({config:e,use:s,recorder:n}){const r={model:e.model??s.model,url:e.url??s.url??se};try{V(r),this.url=r.url,this.model=r.model,this.recorder=n}catch(o){throw new Error(`Invalid Ollama configuration: ${o}`)}}createChatCompletionRequest(e){return new re({url:this.url,model:this.model,chat:e,recorder:this.recorder})}}class re{static{a(this,"OllamaChatCompletionRequest")}chat;url;model;recorder;constructor({url:e,model:s,chat:n,recorder:r}){this.url=e,this.model=s,this.chat=n,this.recorder=r}async execute(){const e={model:this.model,messages:this.chat.toOpenAI().messages,stream:!1,options:{temperature:.7}};this.recorder?.debug?.log(e);let s;try{const n=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const r=await n.json();s={type:"success",id:`ollama-${Date.now()}`,model:this.model,reason:d.Stop,message:{role:"assistant",content:r.message?.content||""},usage:{in:r.prompt_eval_count||0,out:r.eval_count||0},raw:r}}catch(n){console.log(n),s={type:"error",error:{type:"OllamaError",message:n.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(n)}}return this.recorder?.debug?.log(s),s}}const oe={GPT_4_1:"gpt-4.1"},ae=oe.GPT_4_1;class ie{static{a(this,"OpenAIProvider")}name="OpenAI";client;model;recorder;constructor({config:e,use:s,recorder:n}){const r={"api-key":e["api-key"]||s["api-key"],model:e.model||s.model||ae};try{L(r),this.model=r.model,this.client=new q({apiKey:r["api-key"]}),this.recorder=n}catch(o){throw new Error(`Invalid OpenAI configuration: ${o}`)}}createChatCompletionRequest(e){return new ce({client:this.client,model:this.model,chat:e,recorder:this.recorder})}}class ce{static{a(this,"OpenAIChatCompletionRequest")}chat;openai;model;recorder;constructor({client:e,model:s,chat:n,recorder:r}){this.openai=e,this.model=s||"gpt-4o",this.chat=n,this.recorder=r}async execute(){const e={model:this.model,...this.chat.toOpenAI()};this.recorder?.debug?.log(e);let s;try{const n=await this.openai.chat.completions.create(e);s=ue(n)}catch(n){console.error(n),s={type:"error",error:{type:n.type??"Undetermined",message:n.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:n}}return this.recorder?.debug?.log(s),s}}function le(t){switch(t){case"length":return d.Length;case"stop":return d.Stop;case"tool_calls":return d.FunctionCall;default:return d.Error}}a(le,"getStopReason");function ue(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(n=>({id:n.id,name:n.function.name,arguments:n.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:le(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}a(ue,"translate");function pe({useConfig:t,config:e,options:s,recorder:n}){if(t.engine=="openai")return new ie({config:e.openai,use:t,recorder:n});if(t.engine=="anthropic")return new Y({config:e.anthropic,use:t,recorder:n});if(t.engine=="ollama")return new ne({config:e.ollama,use:t,recorder:n});throw new Error("AI Provider is invalid or not supported. Please check your job file.")}a(pe,"getProvider");const y={Running:"running",Success:"success",Fail:"fail"};var m=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(m||{});class de{static{a(this,"Recorder")}instanceId=crypto.randomUUID();level=m.Info;logs=[];writers=[];subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s){const n=typeof s=="string"?{message:s}:s;this.publish({level:e,time:Date.now(),...n})}get info(){return{log:this.logFunction.bind(this,m.Info)}}get debug(){return this.level>m.Debug?null:{log:this.logFunction.bind(this,m.Debug)}}getLogs(e=m.Info){return this.logs.filter(s=>s.level>=e)}}class he{static{a(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}toOpenAI(){const e=[];this.system&&e.push({role:"system",content:this.system});const s=this.tools.length>0?this.tools.map(r=>({type:"function",function:r})):void 0,n=this.messages.map(r=>{switch(r.role){case"tool":return r.content.map(o=>({role:"tool",tool_call_id:o.id,content:o.content}));case"assistant":return{role:r.role,content:r.content,tool_calls:r.toolCalls.map(o=>({id:o.id,type:"function",function:{name:o.name,arguments:JSON.stringify(o.arguments)}}))};default:return{role:r.role,content:r.content}}}).flat(1/0);return{messages:[...e,...n],...s&&{tools:s}}}toAnthropic(){const e=this.messages.map(n=>{switch(n.role){case"assistant":const r=[];return r.push({type:"text",text:n.content}),n.toolCalls&&r.push(...n.toolCalls.map(o=>({type:"tool_use",id:o.id,name:o.name,input:o.arguments}))),{role:"assistant",content:r};case"tool":return{role:"user",content:n.content.map(o=>({type:"tool_result",tool_use_id:o.id,content:o.content}))};default:return{role:"user",content:n.content}}}),s=this.tools.map(n=>({name:n.name,description:n.description,input_schema:n.parameters}));return{system:this.system,messages:e,tools:s}}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}async function me({path:t,defaults:e,loader:s="File"}){let n=null,r="";if(t)try{r=$(t),n=await v(r,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const o of e.formats)try{r=$(e.name+"."+o),n=await v(r,{encoding:"utf-8"});break}catch{continue}if(n===null)throw new Error(`${s} not found, see --help for details`)}return{content:n,format:r.split(".").pop()??""}}a(me,"loadFile");async function fe(t,e){let s="";for(const n of t){const r=await _(n);e?.debug?.log(`many-files parser. For glob "${n}", found ${r.length} files.`);const o=await Promise.all(r.map(async i=>{const l=await v(i,"utf-8");return i+`:
`+l}));s+=o.join(`
`)}return s}a(fe,"loadManyFiles");function ge(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,n=t.match(s);if(n){let r="";return n.groups?.asterisks.length==1?r+=e.stem:r+=e.dir+e.stem,n.groups?.extension?r+=n.groups.extension:r+=e.ext,t.replace(n[0],r)}return t}a(ge,"replaceFilePattern");function ye(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}a(ye,"pathToComponents");async function O(t){const e=B(t);try{await J(e)}catch{await W(e),await O(e)}}a(O,"ensureDirectoryExistence");async function we({filePath:t,content:e}){await O(t),await K(t,e)}a(we,"writeFileWithDirectories");class be{static{a(this,"FileRunPlanner")}constructor(e,s,n){this.source=e,this.bind=s,this.skipConditions=n}async plan(e){const s=[],n=await _(this.source,{withFileTypes:!0});for(const r of n){const o=r.fullpath(),i=ye(o);let l=!1;for(const c of this.skipConditions)if(l=await c.eval({components:i}),l)break;if(!l){const c=await M(o,"utf-8"),p={variables:{[this.bind]:c,...i},tasks:e};s.push(p)}}return s}}class ke{static{a(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async r=>await r.plan(e));return(await Promise.all(s)).flat()}}function C(t,e,s="{{}}"){const n=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(n,(r,o)=>e[o]?e[o]:r),t}a(C,"replaceVariables");class Te{static{a(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=C(this.pattern,e.components,"{}");try{return await j(s,H.F_OK),!0}catch{return!1}}}class F{static{a(this,"Instruct")}type="instruct";prompt;system=null;inputs;outputFormat;tools={};constructor(e,s={response:"string"}){this.prompt=e,this.outputFormat=s}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}compile(e,s){const n={...e,...this.inputs};let r=C(this.prompt,n);if(s?.warnUnused){const o=r.match(/\{\{(.*?)\}\}/g);o&&console.warn(`Warning: The following variables were not replaced: ${o.join(", ")}`)}return r}}function ve(t){return Array.isArray(t)?t:[t]}a(ve,"arrayify");function k(t){return t.slice(0,8)}a(k,"friendly");function Ce(t){return new Promise(e=>setTimeout(e,t))}a(Ce,"delay");const xe={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class Ee{static{a(this,"BraveSearchTool")}name="brave";schema=xe;apiKey;throttle;lastExecTime=0;constructor(e){e&&(this.apiKey=e["api-key"],this.throttle=e.delay??void 0)}setConfig(e){this.apiKey=e["api-key"],this.throttle=e.delay??void 0}async execute(e,s={}){const{searchTerm:n}=e,{recorder:r}=s;if(r?.debug?.log({kind:"heading",message:`Brave: searching for ${n}`}),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await Ce(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const o=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",l=new URL(i);l.searchParams.append("q",n),l.searchParams.append("format","json");const c=await fetch(l.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":o}});if(!c.ok)throw new Error(`HTTP error! status: ${c}`);return await c.json()}catch(o){throw console.error("Error fetching search results:",o),o}}}const _e=new Ee,$e={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Se={name:"calculator",schema:$e,execute:a(async t=>{const{operation:e,a:s,b:n}=t;switch(e){case"add":return`${s} + ${n} = ${s+n}`;case"subtract":return`${s} - ${n} = ${s-n}`;case"multiply":return`${s} * ${n} = ${s*n}`;case"divide":if(n===0)throw new Error("Cannot divide by zero");return`${s} / ${n} = ${s/n}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class Oe{static{a(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let w;function A(){return w||(w=new Oe,w.register(Se),w.register(_e)),w}a(A,"getToolRegistry");const Fe={async convert(t,e){const{recorder:s,toolNames:n}=e,{message:r,system:o,replace:i}=t,l=new F(r);o&&(l.system=o);const c=[...new Set([...n??[],...t.tools??[]])];for(const p of c){const u=A().get(p);l.addTool(u)}if(i){for(const p of i)if(p.source==="file"){const u=ve(p.files),h=await fe(u,s);l.addInput(p.pattern,h)}}return l}};class Ae{static{a(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}const Ie={async convert(t){return{type:"write-to-disk",output:t.output}}},x=new Ae;x.register("write-to-disk",Ie),x.register("chat",Fe);async function I(t,e){const{recorder:s}=e,n=t.tools??void 0,r=t.steps.map(async o=>(o.uses,await x.get(o.uses).convert(o,{recorder:s,toolNames:n})));return Promise.all(r)}a(I,"configToTasks");async function Pe(t,e){const{batch:s}=t;return s.length===1?P(s[0]):new ke(s.map(n=>P(n)))}a(Pe,"configToPlanner");function P(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(n=>Re(n))),new be(t.source,t.bind,e)}}a(P,"batchOptionsToPlanner");function Re(t){switch(t.type){case"file-exist":return new Te(t.pattern)}}a(Re,"skipOptionsToSkipConditions");var b=(t=>(t.Latest="latest",t))(b||{});class De{static{a(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:n,options:r={},recorder:o}=e;if(r.dryRun){o?.debug?.log("Dry run: no action was taken");return}const i=s.output,l=n[b.Latest];if(typeof l=="string"){let c="";i.includes("*")?c=ge(i,n.file):c=C(i,n,"{}"),await we({filePath:c,content:l})}}}class Ue{static{a(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...n}=e;await Ne({instruct:s,...n})}}async function Ne(t){const{instruct:e,chat:s,provider:n,stats:r,variables:o,options:i,recorder:l}=t;if(e.system&&s.addSystem(e.system),s.addUser(e.compile(o,i)),e.hasTools()){const p=Me(e.tools);s.setToolSchemas(p)}if(i?.dryRun)return l?.debug?.log(s),{action:"complete"};let c=!0;for(;c;){const u=await n.createChatCompletionRequest(s).execute();if(r.in+=u.usage.in,r.out+=u.usage.out,u.type==="error")throw new Error(u.error.message);if(u.type==="success")switch(u.reason){case d.Stop:return u.message.content&&(s.addAssistant(u.message.content),o[b.Latest]=u.message.content),c=!1,{action:"continue"};case d.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case d.FunctionCall:{let h=u.message;if(u.message&&(s.addAssistant(h.content,h.toolCalls),o[b.Latest]=u.message.content),h.toolCalls&&h.toolCalls.length>0){const f=await qe(h.toolCalls,e);l?.debug?.log(f);const T=f.map(g=>({id:g.id,content:JSON.stringify(g.results)}));s.addTools(T),c=!0}else c=!1;break}}if(u.type!=="success")throw l?.debug?.log(u),new Error("Unexpected response type")}return{action:"continue"}}a(Ne,"executeChatAction");async function qe(t,e){const s=[];for(const n of t)s.push(new Promise((r,o)=>{const i=e.tools[n.name];if(!i){o(`Tool not found: ${n.name}`);return}let l={};try{const c=JSON.parse(n.arguments);c&&typeof c=="object"&&!Array.isArray(c)&&(l=c)}catch{o(`argument for tool ${n.name} is not valid: ${JSON.stringify(n.arguments)}`)}i.execute(l).then(c=>r({id:n.id,results:c})).catch(o)}));return Promise.all(s)}a(qe,"executeToolCalls");function Me(t){const e=[];for(const[s,n]of Object.entries(t))e.push(n.schema);return e}a(Me,"getToolSchemas");class je{static{a(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,n=s.type,r=this.getHandler(s);if(!r)throw new Error(`No handler registered for action type: ${n}`);if(!r.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${n}`);await r.execute(e)}}function He(){const t=new je;return t.register(new Ue),t}a(He,"createBaseRegistry");function Ke(){const t=He();return t.register(new De),t}a(Ke,"createNodeRegistry");const Je=a((t,...e)=>{const s=a(async r=>{const{recorder:o}=r;let i=[];return"type"in t&&t.type==="serial"?i=await I(t,{recorder:o}):i=[t,...e],i},"prepare");return{execute:a(async r=>{const{provider:o,variables:i,options:l,stats:c,recorder:p}=r,u=crypto.randomUUID(),h=Ke();p.info.log({type:"task",id:u,status:y.Running,message:`[${k(u)}] Starting job`});const f=await s({recorder:p}),T=new he;let g=!1;for(const[R,E]of f.entries()){p.info.log({type:"task",id:u,status:y.Running,message:`[${k(u)}] Processing step ${R+1}: ${E.type}`});try{await h.executeTask({task:E,chat:T,provider:o,variables:i,options:l,stats:c,recorder:p})}catch(D){g=!0,console.error(D)}}return g?p.info.log({type:"task",status:y.Fail,id:u,message:`[${k(u)}] Failed`}):p.info.log({type:"task",status:y.Success,id:u,message:`[${k(u)}] Completed ${f.length} steps`}),{response:i[b.Latest],stats:c}},"execute")}},"serialWorkflow");export{F as I,m as L,de as R,y as T,I as a,A as b,Pe as c,pe as g,G as i,me as l,Je as s};
