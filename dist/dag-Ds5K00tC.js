var ge=Object.defineProperty;var c=(t,e)=>ge(t,"name",{value:e,configurable:!0});import de from"@anthropic-ai/sdk";import{GoogleGenAI as me,Type as he,FinishReason as w}from"@google/genai";import ye from"openai";import{serializeError as Ee}from"serialize-error";import{readFile as Ie,access as we,constants as Te}from"fs/promises";import{glob as Q}from"glob";import{readFile as F,access as j,stat as Pe,writeFile as Ae,mkdir as ve}from"node:fs/promises";import{resolve as B,extname as Ne,dirname as Oe}from"node:path";class E extends Error{static{c(this,"AxleError")}code;id;details;constructor(e,s){super(e,{cause:s?.cause}),this.name=this.constructor.name,this.code=s?.code||"AXLE_ERROR",this.id=s?.id,this.details=s?.details,Object.setPrototypeOf(this,E.prototype)}}const R={CLAUDE_OPUS_4_20250514:"claude-opus-4-20250514",CLAUDE_OPUS_4_LATEST:"claude-opus-4-0",CLAUDE_SONNET_4_20250514:"claude-sonnet-4-20250514",CLAUDE_SONNET_4_LATEST:"claude-sonnet-4-0",CLAUDE_3_7_SONNET_20250219:"claude-3-7-sonnet-20250219",CLAUDE_3_7_SONNET_LATEST:"claude-3-7-sonnet-latest",CLAUDE_3_5_HAIKU_20241022:"claude-3-5-haiku-20241022",CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},V=[R.CLAUDE_3_7_SONNET_LATEST,R.CLAUDE_3_7_SONNET_20250219,R.CLAUDE_3_5_HAIKU_LATEST,R.CLAUDE_3_5_HAIKU_20241022,R.CLAUDE_SONNET_4_LATEST,R.CLAUDE_SONNET_4_20250514,R.CLAUDE_OPUS_4_LATEST,R.CLAUDE_OPUS_4_20250514];var m=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(m||{});const Re=R.CLAUDE_SONNET_4_LATEST;class Se{static{c(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,s){this.model=s??Re,this.client=new de({apiKey:e})}createChatRequest(e,s={}){const{recorder:n}=s;return e.hasFiles()&&!V.includes(this.model)&&n?.warn?.log(`Model ${this.model} may not support multimodal content. Use one of: ${V.join(", ")}`),new be(this,e)}}class be{static{c(this,"AnthropicChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r={model:o,max_tokens:4096,...Me(this.chat)};s?.debug?.log(r);let i;try{const a=await n.messages.create(r);i=Ge(a)}catch(a){i={type:"error",error:{type:a.error.error.type??"Undetermined",message:a.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}}function ee(t){switch(t){case"max_tokens":return m.Length;case"end_turn":return m.Stop;case"stop_sequence":return m.Stop;case"tool_use":return m.FunctionCall;default:return m.Error}}c(ee,"getStopReason$2");function Me(t){const e=t.messages.map(n=>{switch(n.role){case"assistant":const o=[];return o.push({type:"text",text:n.content}),n.toolCalls&&o.push(...n.toolCalls.map(r=>({type:"tool_use",id:r.id,name:r.name,input:r.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:n.content.map(r=>({type:"tool_result",tool_use_id:r.id,content:r.content}))};default:if(typeof n.content=="string")return{role:"user",content:n.content};{const r=[];for(const i of n.content)if(i.type==="text")r.push({type:"text",text:i.text});else if(i.type==="file"){const a=i.file;a.type==="image"?r.push({type:"image",source:{type:"base64",media_type:a.mimeType,data:a.base64}}):a.type==="document"&&a.mimeType==="application/pdf"&&r.push({type:"document",source:{type:"base64",media_type:"application/pdf",data:a.base64}})}return{role:"user",content:r}}}}),s=t.tools.map(n=>({name:n.name,description:n.description,input_schema:n.parameters}));return{system:t.system,messages:e,tools:s}}c(Me,"prepareRequest$2");function Ge(t){const e=ee(t.stop_reason);if(e===m.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===m.FunctionCall){const s=t.content[0],n=s.type==="text"?s.text:"",o=t.content.slice(1).map(r=>{if(r.type==="tool_use")return{id:r.id,name:r.name,arguments:r.input}}).filter(r=>r!==null);return{type:"success",id:t.id,model:t.model,reason:m.FunctionCall,message:{role:t.role,content:n,toolCalls:o},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:ee(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}c(Ge,"translate");const p={GEMINI_1_0_PRO_VISION_LATEST:"gemini-1.0-pro-vision-latest",GEMINI_PRO_VISION:"gemini-pro-vision",GEMINI_1_5_PRO_LATEST:"gemini-1.5-pro-latest",GEMINI_1_5_PRO_001:"gemini-1.5-pro-001",GEMINI_1_5_PRO_002:"gemini-1.5-pro-002",GEMINI_1_5_PRO:"gemini-1.5-pro",GEMINI_1_5_FLASH_LATEST:"gemini-1.5-flash-latest",GEMINI_1_5_FLASH_001:"gemini-1.5-flash-001",GEMINI_1_5_FLASH_001_TUNING:"gemini-1.5-flash-001-tuning",GEMINI_1_5_FLASH:"gemini-1.5-flash",GEMINI_1_5_FLASH_002:"gemini-1.5-flash-002",GEMINI_1_5_FLASH_8B:"gemini-1.5-flash-8b",GEMINI_1_5_FLASH_8B_001:"gemini-1.5-flash-8b-001",GEMINI_1_5_FLASH_8B_LATEST:"gemini-1.5-flash-8b-latest",GEMINI_1_5_FLASH_8B_EXP_0827:"gemini-1.5-flash-8b-exp-0827",GEMINI_1_5_FLASH_8B_EXP_0924:"gemini-1.5-flash-8b-exp-0924",GEMINI_2_5_PRO_EXP_03_25:"gemini-2.5-pro-exp-03-25",GEMINI_2_5_PRO_PREVIEW_03_25:"gemini-2.5-pro-preview-03-25",GEMINI_2_5_FLASH_PREVIEW_04_17:"gemini-2.5-flash-preview-04-17",GEMINI_2_5_FLASH_PREVIEW_05_20:"gemini-2.5-flash-preview-05-20",GEMINI_2_5_FLASH_PREVIEW_04_17_THINKING:"gemini-2.5-flash-preview-04-17-thinking",GEMINI_2_5_PRO_PREVIEW_05_06:"gemini-2.5-pro-preview-05-06",GEMINI_2_5_PRO_PREVIEW_06_05:"gemini-2.5-pro-preview-06-05",GEMINI_2_0_FLASH_EXP:"gemini-2.0-flash-exp",GEMINI_2_0_FLASH:"gemini-2.0-flash",GEMINI_2_0_FLASH_001:"gemini-2.0-flash-001",GEMINI_2_0_FLASH_EXP_IMAGE_GENERATION:"gemini-2.0-flash-exp-image-generation",GEMINI_2_0_FLASH_LITE_001:"gemini-2.0-flash-lite-001",GEMINI_2_0_FLASH_LITE:"gemini-2.0-flash-lite",GEMINI_2_0_FLASH_PREVIEW_IMAGE_GENERATION:"gemini-2.0-flash-preview-image-generation",GEMINI_2_0_FLASH_LITE_PREVIEW_02_05:"gemini-2.0-flash-lite-preview-02-05",GEMINI_2_0_FLASH_LITE_PREVIEW:"gemini-2.0-flash-lite-preview",GEMINI_2_0_PRO_EXP:"gemini-2.0-pro-exp",GEMINI_2_0_PRO_EXP_02_05:"gemini-2.0-pro-exp-02-05",GEMINI_EXP_1206:"gemini-exp-1206",GEMINI_2_0_FLASH_THINKING_EXP_01_21:"gemini-2.0-flash-thinking-exp-01-21",GEMINI_2_0_FLASH_THINKING_EXP:"gemini-2.0-flash-thinking-exp",GEMINI_2_0_FLASH_THINKING_EXP_1219:"gemini-2.0-flash-thinking-exp-1219",GEMINI_2_5_FLASH_PREVIEW_TTS:"gemini-2.5-flash-preview-tts",GEMINI_2_5_PRO_PREVIEW_TTS:"gemini-2.5-pro-preview-tts",LEARNLM_2_0_FLASH_EXPERIMENTAL:"learnlm-2.0-flash-experimental",GEMMA_3_1B_IT:"gemma-3-1b-it",GEMMA_3_4B_IT:"gemma-3-4b-it",GEMMA_3_12B_IT:"gemma-3-12b-it",GEMMA_3_27B_IT:"gemma-3-27b-it",GEMMA_3N_E4B_IT:"gemma-3n-e4b-it"},te=[p.GEMINI_1_0_PRO_VISION_LATEST,p.GEMINI_PRO_VISION,p.GEMINI_1_5_PRO_LATEST,p.GEMINI_1_5_PRO_001,p.GEMINI_1_5_PRO_002,p.GEMINI_1_5_PRO,p.GEMINI_1_5_FLASH_LATEST,p.GEMINI_1_5_FLASH_001,p.GEMINI_1_5_FLASH_001_TUNING,p.GEMINI_1_5_FLASH,p.GEMINI_1_5_FLASH_002,p.GEMINI_1_5_FLASH_8B,p.GEMINI_1_5_FLASH_8B_001,p.GEMINI_1_5_FLASH_8B_LATEST,p.GEMINI_1_5_FLASH_8B_EXP_0827,p.GEMINI_1_5_FLASH_8B_EXP_0924,p.GEMINI_2_5_PRO_EXP_03_25,p.GEMINI_2_5_PRO_PREVIEW_03_25,p.GEMINI_2_5_FLASH_PREVIEW_04_17,p.GEMINI_2_5_FLASH_PREVIEW_05_20,p.GEMINI_2_5_FLASH_PREVIEW_04_17_THINKING,p.GEMINI_2_5_PRO_PREVIEW_05_06,p.GEMINI_2_5_PRO_PREVIEW_06_05,p.GEMINI_2_0_FLASH_EXP,p.GEMINI_2_0_FLASH,p.GEMINI_2_0_FLASH_001,p.GEMINI_2_0_FLASH_EXP_IMAGE_GENERATION,p.GEMINI_2_0_FLASH_LITE_001,p.GEMINI_2_0_FLASH_LITE,p.GEMINI_2_0_FLASH_PREVIEW_IMAGE_GENERATION,p.GEMINI_2_0_FLASH_LITE_PREVIEW_02_05,p.GEMINI_2_0_FLASH_LITE_PREVIEW,p.GEMINI_2_0_PRO_EXP,p.GEMINI_2_0_PRO_EXP_02_05,p.GEMINI_EXP_1206,p.GEMINI_2_0_FLASH_THINKING_EXP_01_21,p.GEMINI_2_0_FLASH_THINKING_EXP,p.GEMINI_2_0_FLASH_THINKING_EXP_1219,p.GEMINI_2_5_FLASH_PREVIEW_TTS,p.GEMINI_2_5_PRO_PREVIEW_TTS,p.LEARNLM_2_0_FLASH_EXPERIMENTAL,p.GEMMA_3_1B_IT,p.GEMMA_3_4B_IT,p.GEMMA_3_12B_IT,p.GEMMA_3_27B_IT,p.GEMMA_3N_E4B_IT],ke=p.GEMINI_2_5_FLASH_PREVIEW_05_20;class xe{static{c(this,"GoogleAIProvider")}name="GoogleAI";client;model;constructor(e,s){this.model=s??ke,this.client=new me({apiKey:e})}createChatRequest(e,s={}){const{recorder:n}=s;return e.hasFiles()&&!te.includes(this.model)&&n?.warn.log(`Model ${this.model} does not support multimodal content. Use one of: ${te.join(", ")}`),new $e(this,e)}}class $e{static{c(this,"GoogleAIChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r=this.prepareRequest(this.chat);s?.debug?.log(r);let i;try{const a=await n.models.generateContent({model:o,...r});i=Le(a,e)}catch(a){s?.error?.log(a),i={type:"error",error:{type:a.name??"Undetermined",message:a.message??"Unexpected error from Google AI"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}prepareRequest(e){let s;e.messages.length===1&&e.messages[0].role=="user"&&typeof e.messages[0].content=="string"?s=e.messages[0].content:s=e.messages.map(o=>{if(o.role==="user"){if(typeof o.content=="string")return{role:"user",parts:[{text:o.content}]};{const r=[];for(const i of o.content)if(i.type==="text")r.push({text:i.text});else if(i.type==="file"){const a=i.file;(a.type==="image"||a.type==="document")&&r.push({inlineData:{mimeType:a.mimeType,data:a.base64}})}return{role:"user",parts:r}}}else if(o.role==="assistant"){const r={role:"assistant",parts:[]};return o.content&&r.parts.push({text:o.content}),o.toolCalls&&(r.parts=r.parts.concat(o.toolCalls.map(i=>{let a;return typeof i.arguments=="string"?a=JSON.parse(i.arguments):a=i.arguments,{functionCall:{id:i.id??void 0,name:i.name,args:a}}}))),r}else if(o.role==="tool")return{role:"user",parts:o.content.map(r=>({functionResponse:{id:r.id??void 0,name:r.name,response:{output:r.content}}}))}});const n={};return e.system&&(n.systemInstruction=e.system),e.tools.length>0&&(n.tools=e.tools.map(o=>({functionDeclarations:[{name:o.name,description:o.description,parameters:{...o.parameters,type:he.OBJECT}}]}))),{contents:s,config:n}}}function Le(t,e){const{recorder:s}=e,n=t.usageMetadata.promptTokenCount,o=t.usageMetadata.totalTokenCount-n,r={in:n,out:o};if(!t)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};if(t.promptFeedback&&t.promptFeedback.blockReason)return{type:"error",error:{type:"Blocked",message:`Response blocked by Google AI: ${t.promptFeedback.blockReason}, ${t.promptFeedback.blockReasonMessage}`},usage:r,raw:t};if(!t.candidates||t.candidates.length===0)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};t.candidates.length>1&&s?.warn?.log(`We received ${t.candidates.length} response candidates`);const i=t.candidates[0],l=(i.content?.parts||[]).map(f=>f.text).filter(f=>f!==void 0).join(""),[u,_]=Fe(i.finishReason);if(u){let f;return t.functionCalls&&(f=t.functionCalls.map(d=>({id:d.id,name:d.name,arguments:JSON.stringify(d.args)}))),{type:"success",id:t.responseId,model:t.modelVersion,reason:t.functionCalls?m.FunctionCall:_,message:{role:"assistant",...l?{content:l}:{},...f?{toolCalls:f}:{}},usage:r,raw:t}}else return{type:"error",error:{type:"Undetermined",message:`Unexpected stop reason: ${_}`},usage:r,raw:t}}c(Le,"translateResponse$2");function Fe(t){switch(t){case w.STOP:return[!0,m.Stop];case w.MAX_TOKENS:return[!0,m.Length];case w.FINISH_REASON_UNSPECIFIED:case w.SAFETY:case w.RECITATION:case w.LANGUAGE:case w.OTHER:case w.BLOCKLIST:case w.PROHIBITED_CONTENT:case w.SPII:case w.MALFORMED_FUNCTION_CALL:case w.IMAGE_SAFETY:return[!1,m.Error]}}c(Fe,"getStopReason$1");const Ce="http://localhost:11434";class Ue{static{c(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,s){this.url=s||Ce,this.model=e}createChatRequest(e,s={}){const{recorder:n}=s;return e.hasFiles()&&n?.warn?.log(`Ollama model ${this.model} multimodal support depends on the specific model. Ensure you're using a vision-capable model like llava.`),new De(this.url,this.model,e)}}class De{static{c(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,s,n){this.url=e,this.model=s,this.chat=n}async execute(e){const{recorder:s}=e,n={model:this.model,stream:!1,options:{temperature:.7},...He(this.chat)};s?.debug?.log(n);let o;try{const r=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!r.ok)throw console.log(r),new Error(`HTTP error! status: ${r.status}`);const i=await r.json();o=We(i)}catch(r){s?.error?.log("Error fetching Ollama response:",r),o={type:"error",error:{type:"OllamaError",message:r.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(r)}}return s?.debug?.log(o),o}}function He(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,n=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(r=>({role:"tool",tool_call_id:r.id,content:r.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(r=>{const i=r.id;return{type:"function",function:{name:r.name,arguments:r.arguments},...i&&{id:i}}})};default:if(typeof o.content=="string")return{role:o.role,content:o.content};{let r="";const i=[];for(const a of o.content)if(a.type==="text")r+=a.text;else if(a.type==="file"){const l=a.file;l.type==="image"&&i.push(l.base64)}return{role:o.role,content:r,...i.length>0&&{images:i}}}}}).flat(1/0);return{messages:[...e,...n],...s&&{tools:s}}}c(He,"prepareRequest$1");function We(t){if(t.done_reason==="stop"&&t.message){const e=t.message.content,s=[];if(t.message.tool_calls)for(const o of t.message.tool_calls)s.push({id:o.id,name:o.function.name,arguments:o.function.arguments});const n=s.length>0;return{type:"success",id:`ollama-${Date.now()}`,model:t.model,reason:n?m.FunctionCall:m.Stop,message:{role:"assistant",content:e,...n&&{toolCalls:s}},usage:{in:t.prompt_eval_count||0,out:t.eval_count||0},raw:t}}return{type:"error",error:{type:"OllamaError",message:"Unexpected error from Ollama"},usage:{in:0,out:0},raw:t}}c(We,"translateResponse$1");const g={GPT_4_1:"gpt-4.1",GPT_4_1_2025_04_14:"gpt-4.1-2025-04-14",GPT_4_1_MINI:"gpt-4.1-mini",GPT_4_1_MINI_2025_04_14:"gpt-4.1-mini-2025-04-14",GPT_4_1_NANO:"gpt-4.1-nano",GPT_4_1_NANO_2025_04_14:"gpt-4.1-nano-2025-04-14",GPT_4O:"gpt-4o",GPT_4O_2024_05_13:"gpt-4o-2024-05-13",GPT_4O_2024_08_06:"gpt-4o-2024-08-06",GPT_4O_2024_11_20:"gpt-4o-2024-11-20",GPT_4O_AUDIO_PREVIEW:"gpt-4o-audio-preview",GPT_4O_AUDIO_PREVIEW_2024_10_01:"gpt-4o-audio-preview-2024-10-01",GPT_4O_AUDIO_PREVIEW_2024_12_17:"gpt-4o-audio-preview-2024-12-17",GPT_4O_AUDIO_PREVIEW_2025_06_03:"gpt-4o-audio-preview-2025-06-03",GPT_4O_MINI:"gpt-4o-mini",GPT_4O_MINI_2024_07_18:"gpt-4o-mini-2024-07-18",GPT_4O_MINI_AUDIO_PREVIEW:"gpt-4o-mini-audio-preview",GPT_4O_MINI_AUDIO_PREVIEW_2024_12_17:"gpt-4o-mini-audio-preview-2024-12-17",GPT_4O_MINI_REALTIME_PREVIEW:"gpt-4o-mini-realtime-preview",GPT_4O_MINI_REALTIME_PREVIEW_2024_12_17:"gpt-4o-mini-realtime-preview-2024-12-17",GPT_4O_MINI_SEARCH_PREVIEW:"gpt-4o-mini-search-preview",GPT_4O_MINI_SEARCH_PREVIEW_2025_03_11:"gpt-4o-mini-search-preview-2025-03-11",GPT_4O_MINI_TRANSCRIBE:"gpt-4o-mini-transcribe",GPT_4O_MINI_TTS:"gpt-4o-mini-tts",GPT_4O_REALTIME_PREVIEW:"gpt-4o-realtime-preview",GPT_4O_REALTIME_PREVIEW_2024_10_01:"gpt-4o-realtime-preview-2024-10-01",GPT_4O_REALTIME_PREVIEW_2024_12_17:"gpt-4o-realtime-preview-2024-12-17",GPT_4O_REALTIME_PREVIEW_2025_06_03:"gpt-4o-realtime-preview-2025-06-03",GPT_4O_SEARCH_PREVIEW:"gpt-4o-search-preview",GPT_4O_SEARCH_PREVIEW_2025_03_11:"gpt-4o-search-preview-2025-03-11",GPT_4O_TRANSCRIBE:"gpt-4o-transcribe",O3_MINI:"o3-mini",O3_MINI_2025_01_31:"o3-mini-2025-01-31",O4_MINI:"o4-mini",O4_MINI_2025_04_16:"o4-mini-2025-04-16"},Be=[g.GPT_4_1,g.GPT_4_1_2025_04_14,g.GPT_4_1_MINI,g.GPT_4_1_MINI_2025_04_14,g.GPT_4_1_NANO,g.GPT_4_1_NANO_2025_04_14,g.GPT_4O,g.GPT_4O_2024_05_13,g.GPT_4O_2024_08_06,g.GPT_4O_2024_11_20,g.GPT_4O_AUDIO_PREVIEW,g.GPT_4O_AUDIO_PREVIEW_2024_10_01,g.GPT_4O_AUDIO_PREVIEW_2024_12_17,g.GPT_4O_AUDIO_PREVIEW_2025_06_03,g.GPT_4O_MINI,g.GPT_4O_MINI_2024_07_18,g.GPT_4O_MINI_AUDIO_PREVIEW,g.GPT_4O_MINI_AUDIO_PREVIEW_2024_12_17,g.GPT_4O_MINI_REALTIME_PREVIEW,g.GPT_4O_MINI_REALTIME_PREVIEW_2024_12_17,g.GPT_4O_MINI_SEARCH_PREVIEW,g.GPT_4O_MINI_SEARCH_PREVIEW_2025_03_11,g.GPT_4O_MINI_TRANSCRIBE,g.GPT_4O_MINI_TTS,g.GPT_4O_REALTIME_PREVIEW,g.GPT_4O_REALTIME_PREVIEW_2024_10_01,g.GPT_4O_REALTIME_PREVIEW_2024_12_17,g.GPT_4O_REALTIME_PREVIEW_2025_06_03,g.GPT_4O_SEARCH_PREVIEW,g.GPT_4O_SEARCH_PREVIEW_2025_03_11,g.GPT_4O_TRANSCRIBE,g.O3_MINI,g.O3_MINI_2025_01_31,g.O4_MINI,g.O4_MINI_2025_04_16];class qe{static{c(this,"OpenAIChatCompletionRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r={model:o,...Ke(this.chat)};s?.debug?.log(r);let i;try{const a=await n.chat.completions.create(r);i=Je(a)}catch(a){s?.error?.log(a),i={type:"error",error:{type:a.type??"Undetermined",message:a.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}}function Xe(t){switch(t){case"length":return m.Length;case"stop":return m.Stop;case"tool_calls":return m.FunctionCall;default:return m.Error}}c(Xe,"getStopReason");function Ke(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,n=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(i=>({role:"tool",tool_call_id:i.id,content:i.content}));case"assistant":const r=o.toolCalls?.map(i=>{const a=i.id;return{type:"function",function:{name:i.name,arguments:typeof i.arguments=="string"?i.arguments:JSON.stringify(i.arguments)},...a&&{id:a}}});return{role:o.role,content:o.content,...r&&{toolCalls:r}};default:if(typeof o.content=="string")return{role:o.role,content:o.content};{const i=[];for(const a of o.content)if(a.type==="text")i.push({type:"text",text:a.text});else if(a.type==="file"){const l=a.file;l.type==="image"&&i.push({type:"image_url",image_url:{url:`data:${l.mimeType};base64,${l.base64}`}})}return{role:o.role,content:i}}}}).flat(1/0);return{messages:[...e,...n],...s&&{tools:s}}}c(Ke,"prepareRequest");function Je(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(n=>({id:n.id,name:n.function.name,arguments:n.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:Xe(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}c(Je,"translateResponse");class ze{static{c(this,"OpenAIResponsesAPI")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r=Ye(this.chat,o);s?.debug?.heading.log("[Open AI Provider] Using the Responses API"),s?.debug?.log(r);let i;try{const a=await n.responses.create(r);i=Ze(a)}catch(a){s?.error?.log(a),i={type:"error",error:{type:a.type??"Undetermined",message:a.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}}function Ye(t,e){const s=t.messages.map(o=>{if(o.role==="tool")return o.content.map(r=>({type:"function_call_output",call_id:r.id,output:r.content}));if(o.role==="assistant"){const r=o.toolCalls?.map(i=>{const a=i.id;return{type:"function",function:{name:i.name,arguments:typeof i.arguments=="string"?i.arguments:JSON.stringify(i.arguments)},...a&&{id:a}}});return{role:o.role,content:o.content,...r&&{toolCalls:r}}}if(typeof o.content=="string")return{role:o.role,content:o.content};{const r=[];for(const i of o.content)if(i.type==="text")r.push({type:"input_text",text:i.text});else if(i.type==="file"){const a=i.file;a.type==="image"?r.push({type:"input_image",image_url:`data:${a.mimeType};base64,${a.base64}`}):a.type==="document"&&r.push({type:"input_file",filename:a.path,file_data:`data:${a.mimeType};base64,${a.base64}`})}return{role:o.role,content:r}}}).flat(1),n={model:e,input:s};return t.system&&(n.instructions=t.system),t.tools.length>0&&(n.tools=t.tools.map(o=>({type:"function",strict:!0,...o}))),n}c(Ye,"prepareResponseRequest");function Ze(t){if(t.error)return{type:"error",error:{type:t.error.code||"undetermined",message:t.error.message||"Response generation failed"},usage:{in:t.usage?.input_tokens??0,out:t.usage?.output_tokens??0},raw:t};const e=t.output?.filter(s=>s.type==="function_call")?.map(s=>({id:s.id||"",name:s.function?.name||"",arguments:s.function?.arguments||""}));return{type:"success",id:t.id,model:t.model||"",reason:t.incomplete_details?m.Error:m.Stop,message:{content:t.output_text||"",role:"assistant",...e?.length&&{toolCalls:e}},usage:{in:t.usage?.input_tokens??0,out:t.usage?.output_tokens??0},raw:t}}c(Ze,"translateResponseToAIResponse");const Qe=g.GPT_4_1;class je{static{c(this,"OpenAIProvider")}name="OpenAI";client;model;constructor(e,s){this.model=s||Qe,this.client=new ye({apiKey:e})}createChatRequest(e,s={}){const{recorder:n}=s;return Be.includes(this.model)?new ze(this,e):new qe(this,e)}}function Ve(t,e){if(!e||Object.keys(e).length===0)throw new E(`The provider ${t} is not configured. Please check your configuration.`);switch(t){case"openai":return new je(e["api-key"],e.model);case"anthropic":return new Se(e["api-key"],e.model);case"googleai":return new xe(e["api-key"],e.model);case"ollama":{const s=e;return new Ue(s.model,s.url)}default:throw new E("The provider is unsupported")}}c(Ve,"getProvider");class Y extends E{static{c(this,"TaskError")}constructor(e,s){super(e,{code:"TASK_ERROR",id:s?.id,details:{taskType:s?.taskType,taskIndex:s?.taskIndex,...s?.details},cause:s?.cause}),Object.setPrototypeOf(this,Y.prototype)}}const I={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var P=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(P||{});class et{static{c(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=P.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=P.Debug>=this.currentLevel?this.createLoggingFunction(P.Debug):null,this._info=P.Info>=this.currentLevel?this.createLoggingFunction(P.Info):null,this._warn=P.Warn>=this.currentLevel?this.createLoggingFunction(P.Warn):null,this._error=this.createLoggingFunction(P.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s,...n){let o=n.map(r=>typeof r=="string"?{message:r}:r instanceof Error?Ee(r):r);this.publish({level:e,time:Date.now(),kind:s,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=P.Info){return this.logs.filter(s=>s.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}async function tt({path:t,defaults:e,loader:s="File"}){let n=null,o="";if(t)try{o=B(t),n=await F(o,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const r of e.formats)try{o=B(e.name+"."+r),n=await F(o,{encoding:"utf-8"});break}catch{continue}if(n===null)throw new Error(`${s} not found, see --help for details`)}return{content:n,format:o.split(".").pop()??""}}c(tt,"loadFile");async function st(t,e){let s="";for(const n of t){const o=await Q(n);e?.debug?.log(`many-files parser. For glob "${n}", found ${o.length} files.`);const r=await Promise.all(o.map(async i=>{const a=await F(i,"utf-8");return i+`:
`+a}));s+=r.join(`
`)}return s}c(st,"loadManyFiles");function nt(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,n=t.match(s);if(n){let o="";return n.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,n.groups?.extension?o+=n.groups.extension:o+=e.ext,t.replace(n[0],o)}return t}c(nt,"replaceFilePattern");function rt(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}c(rt,"pathToComponents");async function se(t){const e=Oe(t);try{await j(e)}catch{await ve(e),await se(e)}}c(se,"ensureDirectoryExistence");async function ot({filePath:t,content:e}){await se(t),await Ae(t,e)}c(ot,"writeFileWithDirectories");const ne=[".jpg",".jpeg",".png",".gif",".webp",".bmp",".tiff"],re=[".pdf"],oe=20*1024*1024;async function q(t){const e=B(t);try{await j(e)}catch{throw new Error(`File not found: ${t}`)}const s=await Pe(e);if(s.size>oe)throw new Error(`File too large: ${s.size} bytes. Maximum allowed: ${oe} bytes`);const n=Ne(e).toLowerCase();let o,r;if(ne.includes(n))switch(o="image",n){case".jpg":case".jpeg":r="image/jpeg";break;case".png":r="image/png";break;case".gif":r="image/gif";break;case".webp":r="image/webp";break;case".bmp":r="image/bmp";break;case".tiff":r="image/tiff";break;default:r="image/jpeg"}else if(re.includes(n))o="document",r="application/pdf";else throw new Error(`Unsupported file type: ${n}. Supported types: ${[...ne,...re].join(", ")}`);const a=(await F(e)).toString("base64");return{path:e,base64:a,mimeType:r,size:s.size,name:e.split("/").pop()||"",type:o}}c(q,"loadFileAsBase64");function it(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):at(t.using,e)?!t.jobs||typeof t.jobs!="object"?(e&&(e.value="Missing or invalid 'jobs' property"),!1):ie(t.jobs,e)?!0:(e&&(e.value=`Invalid 'jobs' property: ${e?.value}`),!1):(e&&(e.value=`Invalid 'using' property: ${e?.value}`),!1)}c(it,"isJobConfig");function at(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(typeof t.engine!="string")return e&&(e.value="Missing or invalid 'engine' property"),!1;if(!["openai","anthropic","ollama","googleai"].includes(t.engine))return e&&(e.value="Invalid provider type. Must be 'openai', 'anthropic', 'googleai', or 'ollama'"),!1;switch(t.engine){case"ollama":if("model"in t&&typeof t.model!="string")return e&&(e.value="Property 'model' must be a string"),!1;if("url"in t&&typeof t.url!="string")return e&&(e.value="Property 'url' must be a string"),!1;break;case"googleai":case"anthropic":case"openai":if("api-key"in t&&typeof t["api-key"]!="string")return e&&(e.value="Property 'api-key' must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Property 'model' must be a string"),!1;break}return!0}c(at,"isUsing");function ie(t,e){for(const[s,n]of Object.entries(t))if(!ct(n,e))return e&&(e.value=`Invalid job '${s}': ${e?.value}`),!1;return!0}c(ie,"isDAGJob");function ct(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(!ut(t,e))return!1;if("dependsOn"in t&&t.dependsOn!==void 0){const s=t.dependsOn;if(typeof s!="string")if(Array.isArray(s)){for(let n=0;n<s.length;n++)if(typeof s[n]!="string")return e&&(e.value=`Dependency at index ${n} must be a string`),!1}else return e&&(e.value="Property 'dependsOn' must be a string or array of strings"),!1}return!0}c(ct,"isDAGJobValue");function ut(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):"batch"in t?_t(t,e):lt(t,e)}c(ut,"isJob");function lt(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if("batch"in t)return e&&(e.value="Serial job should not have a batch property"),!1;if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}if(!Array.isArray(t.steps))return e&&(e.value="Property 'steps' must be an array"),!1;for(let s=0;s<t.steps.length;s++)if(!ae(t.steps[s],e))return e&&(e.value=`Invalid step at index ${s}: ${e?.value}`),!1;return!0}c(lt,"isSerialJob");function _t(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}if(!Array.isArray(t.batch))return e&&(e.value="Property 'batch' must be an array"),!1;for(let s=0;s<t.batch.length;s++){const n=t.batch[s];if(!n||typeof n!="object")return e&&(e.value=`Batch item at index ${s} must be an object`),!1;if(n.type!=="files")return e&&(e.value=`Batch item at index ${s} must have type 'files'`),!1;if(typeof n.source!="string")return e&&(e.value=`Batch item at index ${s} must have a string 'source' property`),!1;if(typeof n.bind!="string")return e&&(e.value=`Batch item at index ${s} must have a string 'bind' property`),!1;if(n["skip-if"]!==void 0){if(!Array.isArray(n["skip-if"]))return e&&(e.value=`Batch item at index ${s} must have an array 'skip-if' property`),!1;for(let o=0;o<n["skip-if"].length;o++)if(!ft(n["skip-if"][o],e))return e&&(e.value=`Invalid skip condition at index ${o} in batch item ${s}: ${e?.value}`),!1}}if(!Array.isArray(t.steps))return e&&(e.value="Property 'steps' must be an array"),!1;for(let s=0;s<t.steps.length;s++)if(!ae(t.steps[s],e))return e&&(e.value=`Invalid step at index ${s}: ${e?.value}`),!1;return!0}c(_t,"isBatchJob");function ft(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):t.type!=="file-exist"?(e&&(e.value="Property 'type' must be 'file-exist'"),!1):typeof t.pattern!="string"?(e&&(e.value="Property 'pattern' must be a string"),!1):!0}c(ft,"isSkipOptions");function ae(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):!t.uses||typeof t.uses!="string"?(e&&(e.value="Step must have a string 'uses' property"),!1):t.uses==="chat"?pt(t,e):t.uses==="write-to-disk"?gt(t,e):(e&&(e.value=`Unknown uses type: ${t.uses}`),!1)}c(ae,"isStep");function pt(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(t.uses!=="chat")return e&&(e.value="Uses must be 'chat'"),!1;if(typeof t.message!="string")return e&&(e.value="Property 'message' must be a string"),!1;if(t.output!==void 0){if(!t.output||typeof t.output!="object"||Array.isArray(t.output))return e&&(e.value="Property 'output' must be an object"),!1;const s=["string","string[]","number","boolean"];for(const[n,o]of Object.entries(t.output))if(typeof n!="string"||typeof o!="string"||!s.includes(o))return e&&(e.value="Property 'output' must be a Record<string, ResTypeStrings> where ResTypeStrings is 'string' | 'string[]' | 'number' | 'boolean'"),!1}if(t.system!==void 0&&typeof t.system!="string")return e&&(e.value="Property 'system' must be a string"),!1;if(t.replace!==void 0){if(!Array.isArray(t.replace))return e&&(e.value="Property 'replace' must be an array"),!1;for(let s=0;s<t.replace.length;s++)if(!dt(t.replace[s],e))return e&&(e.value=`Invalid replace at index ${s}: ${e?.value}`),!1}if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}if(t.images!==void 0){if(!Array.isArray(t.images))return e&&(e.value="Property 'images' must be an array"),!1;for(let s=0;s<t.images.length;s++)if(!mt(t.images[s],e))return e&&(e.value=`Invalid image at index ${s}: ${e?.value}`),!1}if(t.documents!==void 0){if(!Array.isArray(t.documents))return e&&(e.value="Property 'documents' must be an array"),!1;for(let s=0;s<t.documents.length;s++)if(!ht(t.documents[s],e))return e&&(e.value=`Invalid document at index ${s}: ${e?.value}`),!1}return!0}c(pt,"isChatStep");function gt(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):t.uses!=="write-to-disk"?(e&&(e.value="Uses must be 'write-to-disk'"),!1):typeof t.output!="string"?(e&&(e.value="Property 'output' must be a string"),!1):!0}c(gt,"isWriteToDiskStep");function dt(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(typeof t.pattern!="string")return e&&(e.value="Property 'pattern' must be a string"),!1;if(t.source!=="file")return e&&(e.value="Property 'source' must be 'file'"),!1;if(typeof t.files!="string"&&!Array.isArray(t.files))return e&&(e.value="Property 'files' must be a string or an array of strings"),!1;if(Array.isArray(t.files)){for(let s=0;s<t.files.length;s++)if(typeof t.files[s]!="string")return e&&(e.value=`Files entry at index ${s} must be a string`),!1}return!0}c(dt,"isReplace");function mt(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):typeof t.file!="string"?(e&&(e.value="Property 'file' must be a string"),!1):!0}c(mt,"isImageReference");function ht(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):typeof t.file!="string"?(e&&(e.value="Property 'file' must be a string"),!1):!0}c(ht,"isDocumentReference");class yt{static{c(this,"FileRunPlanner")}constructor(e,s,n=[]){this.source=e,this.bind=s,this.skipConditions=n}async plan(e){const s=[],n=await Q(this.source,{withFileTypes:!0});for(const o of n){const r=o.fullpath(),i=rt(r);let a=!1;for(const l of this.skipConditions)if(a=await l.eval({components:i}),a)break;if(!a){const l=await Ie(r,"utf-8"),u={variables:{[this.bind]:l,...i},tasks:e};s.push(u)}}return s}}class Et{static{c(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async o=>await o.plan(e));return(await Promise.all(s)).flat()}}function X(t,e,s="{{}}"){const n=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(n,(o,r)=>{if(Object.prototype.hasOwnProperty.call(e,r)){const i=e[r];return i==null?"":String(i)}return o}),t}c(X,"replaceVariables");class It{static{c(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=X(this.pattern,e.components,"{}");try{return await we(s,Te.F_OK),!0}catch{return!1}}}var N=(t=>(t.String="string",t.List="string[]",t.Number="number",t.Boolean="boolean",t))(N||{});const ce={response:N.String};class ue{static{c(this,"AbstractInstruct")}type="instruct";_result=void 0;prompt;system=null;inputs={};tools={};files=[];resFormat;rawResponse;finalPrompt;constructor(e,s){this.prompt=e,this.resFormat=s}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}addImage(e){if(e.type!=="image")throw new Error(`Expected image file, got ${e.type}`);this.files.push(e)}addFile(e){this.files.push(e)}hasTools(){return Object.keys(this.tools).length>0}hasFiles(){return this.files.length>0}get result(){return this._result}compile(e,s={}){const n=this.getFinalUserPrompt(e,s),o=this.getFormatInstructions();return n+`
`+o}getFinalUserPrompt(e,s={}){const{recorder:n,options:o}=s,r={...e,...this.inputs};let i=X(this.prompt,r);if(o?.warnUnused){const a=i.match(/\{\{(.*?)\}\}/g);if(a)throw n?.error.log(`Warning unused variables ${a.join(", ")}`),new Error(`Unused variables: ${a.join(", ")}`)}return i}getFormatInstructions(){let e="";for(const[s,n]of Object.entries(this.resFormat))switch(this.resFormat[s]){case N.String:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a string.`;break;case N.Number:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. the answer must be a number.`;break;case N.Boolean:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a true/false.`;break;case N.List:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a list of strings. Each string should be in a new line.`;break}return e}finalize(e,s){this.rawResponse=e;const n={},o=Object.keys(this.resFormat);if(o.length===0){if(e.trim()==="{}"||e.trim()==="")return{};throw new Error("Output format is empty, but rawValue is not an empty object representation or empty string.")}s=s||this.parseTaggedSections(e);for(const r of o){const i=r;let a;const l=s.tags[i];if(l)a=l;else throw new Error(`Expected results with tag ${i} but it does not exist`);const u=this.resFormat[r];try{const _=this.typeResponses(u,a);n[r]=_}catch(_){throw new Error(`Cannot convert value of key ${i} to ${u}: ${_.message}`)}}return this._result=n,n}parseTaggedSections(e){const s=/<(\w+)>(.*?)<\/\1>/gs,n={};let o=e;return o=o.replace(s,(r,i,a)=>(n[i]=a,"")),{tags:n,remaining:o.trim()}}typeResponses(e,s){let n;switch(e){case N.String:n=s;break;case N.Number:if(n=parseFloat(s),isNaN(n))throw new Error(`Cannot parse '${s}' as number. Expected a numeric string.`);break;case N.Boolean:const o=s.toLowerCase();if(o==="true")n=!0;else if(o==="false")n=!1;else throw new Error(`Cannot parse '${s}' as boolean. Expected 'true' or 'false'.`);break;case N.List:s===""?n=[]:n=s.split(`
`).map(r=>r.trim()).filter(r=>r.length>0);break}return n}}class k extends ue{static{c(this,"Instruct")}constructor(e,s){super(e,s)}static with(e,s){return s?new k(e,s):new k(e,ce)}}function $(t){return Array.isArray(t)?t:[t]}c($,"arrayify");function A(t,e){return e?`${e}:${t.slice(0,8)}`:t.slice(0,8)}c(A,"friendly");function wt(t){return new Promise(e=>setTimeout(e,t))}c(wt,"delay");const Tt={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class Pt{static{c(this,"BraveSearchTool")}name="brave";schema=Tt;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:s}=e;this.apiKey=e["api-key"],this.throttle=s?1100/s:void 0}async execute(e,s={}){const{searchTerm:n}=e,{recorder:o}=s;if(o?.debug?.heading.log(`Brave: searching for ${n}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await wt(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const r=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",a=new URL(i);a.searchParams.append("q",n),a.searchParams.append("format","json");const l=await fetch(a.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":r}});if(!l.ok)throw new Error(`[Brave] HTTP error ${l.status}: ${l.statusText}`);return await l.json()}catch(r){throw o?.error.log("[Brave] Error fetching search results:",r),r}}}const At=new Pt,vt={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Nt={name:"calculator",schema:vt,execute:c(async t=>{const{operation:e,a:s,b:n}=t;switch(e){case"add":return`${s} + ${n} = ${s+n}`;case"subtract":return`${s} - ${n} = ${s-n}`;case"multiply":return`${s} * ${n} = ${s*n}`;case"divide":if(n===0)throw new Error("Cannot divide by zero");return`${s} / ${n} = ${s/n}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class Ot{static{c(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let L;function le(){return L||(L=new Ot,L.register(Nt),L.register(At)),L}c(le,"getToolRegistry");const Rt={async convert(t,e){const{recorder:s,toolNames:n}=e,{message:o,system:r,replace:i}=t;let a;t.output?a=k.with(o,t.output):a=k.with(o),r&&(a.system=r);const l=[...new Set([...n??[],...t.tools??[]])];for(const u of l){const _=le().get(u);a.addTool(_)}if(i){for(const u of i)if(u.source==="file"){const _=$(u.files),f=await st(_,s);a.addInput(u.pattern,f)}}if(t.images)for(const u of t.images)try{const _=await q(u.file);a.addFile(_)}catch(_){throw new Error(`Failed to load image '${u.file}': ${_.message}`)}if(t.documents)for(const u of t.documents)try{const _=await q(u.file);a.addFile(_)}catch(_){throw new Error(`Failed to load document '${u.file}': ${_.message}`)}return a}};class St{static{c(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}class K{static{c(this,"WriteOutputTask")}constructor(e,s=["response"]){this.output=e,this.keys=s}type="write-to-disk"}const bt={async convert(t){if(t.keys){const e=$(t.keys);return new K(t.output,e)}return new K(t.output)}},J=new St;J.register("write-to-disk",bt),J.register("chat",Rt);async function C(t,e){const{recorder:s}=e,n=t.tools??void 0,o=t.steps.map(async r=>(r.uses,await J.get(r.uses).convert(r,{recorder:s,toolNames:n})));return Promise.all(o)}c(C,"configToTasks");async function _e(t,e){const{batch:s}=t;return s.length===1?fe(s[0]):new Et(s.map(n=>fe(n)))}c(_e,"configToPlanner");function fe(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(n=>Mt(n))),new yt(t.source,t.bind,e)}}c(fe,"batchOptionsToPlanner");function Mt(t){switch(t.type){case"file-exist":return new It(t.pattern)}}c(Mt,"skipOptionsToSkipConditions");function Gt(t){return t.success===!1&&t.error!==void 0}c(Gt,"isErrorResult");function U(t,e){return{response:t,stats:e,success:!0}}c(U,"createResult");function D(t,e,s){return{response:e,stats:s,error:t,success:!1}}c(D,"createErrorResult");class kt{static{c(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addUserWithFiles(e,s=[]){if(s.length===0){this.addUser(e);return}const n=[{type:"text",text:e}];for(const o of s)n.push({type:"file",file:o});this.messages.push({role:"user",content:n})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}hasFiles(){return this.messages.some(e=>Array.isArray(e.content)&&e.content.some(s=>s.type==="file"))}getTextContent(e){return typeof e=="string"?e:e.filter(n=>n.type==="text").map(n=>n.text).join(" ")}getFiles(e){return typeof e=="string"?[]:e.filter(s=>s.type==="file").map(s=>s.file)}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}class xt{static{c(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:n,options:o={},recorder:r}=e,i=s.output,a=s.keys??[];if(o?.warnUnused){const _=a.filter(f=>!(f in n));_.length>0&&r?.warn?.log(`[Write To Disk] The following keys were not found in the variables: ${_.join(", ")}`)}let l="";if(a.length===1?l=n[a[0]]??"<not found>":l=a.map(_=>`[${_}]:
${n[_]??"<not found>"}
`).join(`
`),o?.dryRun){r?.info?.log("[Dry run] Write to Disk is not executed.");return}let u="";i.includes("*")?u=nt(i,n.file):u=X(i,n,"{}"),await ot({filePath:u,content:l})}}var H=(t=>(t.LastResult="lastResult",t))(H||{});function $t(t,e,s){const{options:n,recorder:o}=s,r=n?.warnUnused??!0;for(const[i,a]of Object.entries(t))r&&e[i]&&o?.warn?.log(`Warning: Variable "${i}" is being overwritten. Previous value: ${e[i]}, new value: ${a}`),e[i]=a}c($t,"setResultsIntoVariables");class Lt{static{c(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...n}=e;await Ft({instruct:s,...n})}}async function Ft(t){const{instruct:e,chat:s,provider:n,stats:o,variables:r,options:i,recorder:a}=t;e.system&&s.addSystem(e.system);const l=e.compile(r,{recorder:a,options:i});if(e.hasFiles()?s.addUserWithFiles(l,e.files):s.addUser(l),e.hasTools()){const _=Ut(e.tools);s.setToolSchemas(_)}if(i?.dryRun)return a?.debug?.log(s),{action:"complete"};let u=!0;for(;u;){const f=await n.createChatRequest(s,{recorder:a}).execute({recorder:a});if(o.in+=f.usage.in,o.out+=f.usage.out,f.type==="error")throw new Error(JSON.stringify(f.error));if(f.type==="success")switch(f.reason){case m.Stop:{if(f.message.content){const d=f.message.content;s.addAssistant(d);const h=e.finalize(d);$t(h,r,{options:i,recorder:a}),r[H.LastResult]=h}return u=!1,{action:"continue"}}case m.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case m.FunctionCall:{let d=f.message;if(f.message&&s.addAssistant(d.content,d.toolCalls),d.toolCalls&&d.toolCalls.length>0){const h=await Ct(d.toolCalls,e,{recorder:a});a?.debug?.log(h),s.addTools(h),u=!0}else u=!1;break}}if(f.type!=="success")throw a?.debug?.log(f),new Error("Unexpected response type")}return{action:"continue"}}c(Ft,"executeChatAction");async function Ct(t,e,s={}){const{recorder:n}=s,o=[];for(const r of t)o.push(new Promise((i,a)=>{const l=e.tools[r.name];if(!l){a(`Tool not found: ${r.name}`);return}n?.debug?.heading.log(`Executing tool ${l.name}`);let u={};try{u=typeof r.arguments=="string"?JSON.parse(r.arguments):r.arguments}catch{a(`argument for tool ${r.name} is not valid: ${JSON.stringify(r.arguments)}`)}l.execute(u).then(_=>{n?.debug?.log(`Complete tool ${l.name}: ${r.id}`),i({id:r.id,name:r.name,content:JSON.stringify(_)})}).catch(a)}));return Promise.all(o)}c(Ct,"executeToolCalls");function Ut(t){const e=[];for(const[s,n]of Object.entries(t))e.push(n.schema);return e}c(Ut,"getToolSchemas");class Dt{static{c(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,n=s.type,o=this.getHandler(s);if(!o)throw new Error(`No handler registered for action type: ${n}`);if(!o.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${n}`);await o.execute(e)}}function Ht(){const t=new Dt;return t.register(new Lt),t}c(Ht,"createBaseRegistry");function Wt(){const t=Ht();return t.register(new xt),t}c(Wt,"createNodeRegistry");const z=c((t,...e)=>{const s=c(async o=>{const{recorder:r}=o;let i=[];return"steps"in t?i=await C(t,{recorder:r}):i=[t,...e],i},"prepare");return{execute:c(async o=>{const{provider:r,variables:i,options:a,stats:l,recorder:u,name:_}=o,f=crypto.randomUUID(),d=Wt();u?.info?.log({type:"task",id:f,status:I.Running,message:`[${A(f,_)}] Starting job`});try{const h=await s({recorder:u}),y=new kt;for(const[S,T]of h.entries()){u?.info?.log({type:"task",id:f,status:I.Running,message:`[${A(f,_)}] Processing step ${S+1}: ${T.type}`});try{await d.executeTask({task:T,chat:y,provider:r,variables:i,options:a,stats:l,recorder:u})}catch(v){throw v instanceof E?v:new Y(`Error executing task ${T.type}`,{id:f,taskType:T.type,taskIndex:S,cause:v instanceof Error?v:new Error(String(v))})}}return u?.info?.log({type:"task",status:I.Success,id:f,message:`[${A(f,_)}] Completed ${h.length} steps`}),U(i[H.LastResult],l)}catch(h){const y=h instanceof E?h:new E("Serial workflow execution failed",{id:f,cause:h instanceof Error?h:new Error(String(h))});return u?.info?.log({type:"task",status:I.Fail,id:f,message:`[${A(f,_)}] Failed: ${y.message}`}),u?.error.log(y),D(y,i[H.LastResult],l)}},"execute")}},"serialWorkflow"),pe=c((t,...e)=>{const s=c(async o=>{const{recorder:r}=o;let i=[],a=null;if("batch"in t){const l=t;a=await _e(l),i=await C(l,{recorder:r})}else a=t,i=[...e];return[a,i]},"prepare");return{execute:c(async o=>{const{provider:r,variables:i,options:a,stats:l,recorder:u,name:_}=o,f=crypto.randomUUID();try{const[d,h]=await s({recorder:u}),y=await d.plan(h);if(u?.debug?.heading.log("Runs",y),y.length===0)return u?.info?.log("No runs to execute"),U([],l);let S=0;u?.info?.log({type:"task",status:I.Running,id:f,message:`[${A(f,"CRW")}] Working on 0/${y.length}`});const T=c(async(O,W)=>{try{return await z(...O.tasks).execute({provider:r,variables:{...O.variables,...i},options:a,stats:l,recorder:u,name:`${_}-${W}`})}catch(b){const Z=b instanceof E?b:new E("Error executing run",{cause:b instanceof Error?b:new Error(String(b))});return u?.error?.log(Z),D(Z,null,l)}finally{S++,u?.info?.log({type:"task",status:I.Running,id:f,message:`[${A(f,"CRW")}] Working on ${S}/${y.length}`})}},"executeRun"),v=5;let G=[];for(let O=0;O<y.length;O+=v){const W=y.slice(O,O+v),b=await Promise.all(W.map(T));G=G.concat(b)}const M=G.some(Gt);u?.info?.log({type:"task",status:M?I.PartialSuccess:I.Success,id:f,message:`[${A(f,"CRW")}] All jobs (${y.length}) completed${M?" with some errors":""}`});const x=G.map(O=>O.response);return U(x,l)}catch(d){const h=d instanceof E?d:new E("Concurrent workflow execution failed",{id:f,cause:d instanceof Error?d:new Error(String(d))});return u?.error?.log(h),D(h,null,l)}},"execute")}},"concurrentWorkflow");class Bt{static{c(this,"DAGParser")}static parse(e){const s=new Map;for(const[o,r]of Object.entries(e)){const i=this.parseNodeDefinition(o,r);s.set(o,i)}return this.validateDependencies(s),this.checkForCycles(s),{stages:this.createExecutionStages(s),nodes:s}}static parseNodeDefinition(e,s){if(this.isSimpleTask(s))return{id:e,tasks:Array.isArray(s)?s:[s],dependencies:[],executionType:"serial"};if(this.isConcurrentNodeDefinition(s)){const i=s,a=i.dependsOn?$(i.dependsOn):[];return{id:e,tasks:i.tasks,dependencies:a,planner:i.planner,executionType:"concurrent"}}const n=s,o=n.dependsOn?$(n.dependsOn):[],r=$(n.task);return{id:e,tasks:r,dependencies:o,executionType:"serial"}}static isSimpleTask(e){return e.type||Array.isArray(e)}static isConcurrentNodeDefinition(e){return e&&typeof e=="object"&&"planner"in e}static validateDependencies(e){for(const s of e.values())for(const n of s.dependencies)if(!e.has(n))throw new E(`Node "${s.id}" depends on non-existent node "${n}"`)}static checkForCycles(e){const s=new Set,n=new Set,o=c(r=>{if(n.has(r))return!0;if(s.has(r))return!1;s.add(r),n.add(r);const i=e.get(r);for(const a of i.dependencies)if(o(a))return!0;return n.delete(r),!1},"hasCycle");for(const r of e.keys())if(o(r))throw new E(`Circular dependency detected involving node "${r}"`)}static createExecutionStages(e){const s=[],n=new Set,o=new Set(e.keys());for(;o.size>0;){const r=[];for(const i of o)e.get(i).dependencies.every(u=>n.has(u))&&r.push(i);if(r.length===0)throw new E("Unable to resolve DAG dependencies - possible circular reference");s.push(r),r.forEach(i=>{n.add(i),o.delete(i)})}return s}}class qt{static{c(this,"DAGJobToDefinition")}static async convert(e,s){const{recorder:n}=s,o={};for(const[r,i]of Object.entries(e)){const{dependsOn:a,...l}=i;if("batch"in l){const u=l,_=await _e(u),f=await C(u,{recorder:n}),d={planner:_,tasks:f,...a?{dependsOn:a}:{}};o[r]=d}else{const u=await C(l,{recorder:n});if(a){const _={task:u,dependsOn:a};o[r]=_}else o[r]=u}}return o}}async function Xt(t,e,s,n={}){const{variables:o}=s,r=e.nodes.get(t);try{let i;if(r.executionType==="concurrent"&&r.planner?i=await pe(r.planner,...r.tasks).execute({...s,variables:o,name:t}):i=await z(...r.tasks).execute({...s,variables:o,name:t}),!i.success)throw new E(`Node "${t}" failed: ${i.error?.message}`);return i.response}catch(i){if(!n.continueOnError)throw i;return null}}c(Xt,"executeNode");const Kt=c((t,e={})=>{const s=c(async(o,r)=>{const{recorder:i}=r,a={value:""};return ie(o,a)?await qt.convert(o,r):(i?.warn?.log(a),o)},"prepare");return{execute:c(async o=>{const{stats:r,recorder:i}=o,{maxConcurrency:a=3}=e,l=crypto.randomUUID();try{const u=await s(t,{recorder:i});i?.debug?.log(u);const _=Bt.parse(u),f=new Map;i?.info?.log({type:"task",id:l,status:I.Running,message:`[${A(l)}] Starting workflow execution with ${_.stages.length} stages`});for(const[h,y]of _.stages.entries()){i?.info?.log({type:"task",id:l,status:I.Running,message:`[${A(l)}] Stage ${h+1}/${_.stages.length}, executing ${y.length} nodes: ${y.join(", ")}`});const S=Math.min(y.length,a);for(let T=0;T<y.length;T+=S){const v=y.slice(T,T+S);(await Promise.all(v.map(async M=>{const x=await Xt(M,_,o,e);return{nodeId:M,result:x}}))).forEach(({nodeId:M,result:x})=>{f.set(M,x)})}}i?.info?.log({type:"task",status:I.Success,id:l,message:`[${A(l)}] Workflow execution completed successfully`});const d=Object.fromEntries(f);return U(d,r)}catch(u){const _=u instanceof E?u:new E("DAG workflow execution failed",{id:l,cause:u instanceof Error?u:new Error(String(u))});return i?.info?.log({type:"task",status:I.Fail,id:l,message:`[${A(l)}] Workflow execution failed: ${_.message}`}),i?.error?.log(_),D(_,null,r)}},"execute")}},"dagWorkflow");export{E as A,ce as D,k as I,P as L,et as R,I as T,K as W,ue as a,tt as b,pe as c,Kt as d,le as e,Ve as g,it as i,q as l,z as s};
