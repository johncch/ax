#!/usr/bin/env node
var O=Object.defineProperty;var p=(e,t)=>O(e,"name",{value:t,configurable:!0});import{Command as A}from"@commander-js/extra-typings";import{l as I,i as W,T as u,L as d,R as D,g as L,b as P,d as J}from"./dag-DFzmn3km.js";import R from"yaml";import l from"chalk";import T from"node:readline";import{access as N,mkdir as M,writeFile as _,appendFile as U}from"node:fs/promises";import"@anthropic-ai/sdk";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:path";function z(e,t){if(typeof e!="object"||e===null)return t&&(t.value="Config: must be a non-null object"),!1;if("openai"in e){const n=e.openai;if(typeof n!="object"||n===null)return t&&(t.value="Config: openai must be an object"),!1;if(typeof n["api-key"]!="string")return t&&(t.value="Config: openai.api-key must be a string"),!1;if("model"in n&&typeof n.model!="string")return t&&(t.value="Config: openai.model must be a string"),!1}if("anthropic"in e){const n=e.anthropic;if(typeof n!="object"||n===null)return t&&(t.value="Config: anthropic must be an object"),!1;if(typeof n["api-key"]!="string")return t&&(t.value="Config: anthropic.api-key must be a string"),!1;if("model"in n&&typeof n.model!="string")return t&&(t.value="Config: anthropic.model must be a string"),!1}if("ollama"in e){const n=e.ollama;if(typeof n!="object"||n===null)return t&&(t.value="Config: ollama must be an object"),!1;if("url"in n&&typeof n.url!="string")return t&&(t.value="Config: ollama.url must be a string"),!1;if("model"in n&&typeof n.model!="string")return t&&(t.value="Config: ollama.model must be a string"),!1}if("brave"in e){const n=e.brave;if(typeof n!="object"||n===null)return t&&(t.value="Config: brave must be an object"),!1;if(typeof n["api-key"]!="string")return t&&(t.value="Config: brave.api-key must be a string"),!1;if("rateLimit"in n&&typeof n.rateLimit!="number")return t&&(t.value="Config: brave.rateLimit must be a number"),!1}return!0}p(z,"isServiceConfig");const B="ax.job",G=["yaml","yml","json"];async function H({path:e,options:t,recorder:n}){const{content:o,format:s}=await I({path:e,defaults:{name:B,formats:G},loader:"Job File"});let i=null;if(s==="json")i=JSON.parse(o);else if(s==="yaml"||s==="yml")i=R.parse(o);else throw new Error("Invalid job file format");n?.debug?.heading.log("The Job Object"),n?.debug?.log(i);const a={value:""};if(W(i,a))return i;throw new Error(`The job file is not valid: ${a.value}`)}p(H,"getJobConfig");const K="ax.config",V=["yaml","yml","json"];async function X({configPath:e,options:t,recorder:n}){const{content:o,format:s}=await I({path:e,defaults:{name:K,formats:V},loader:"Config File"});let i=null;if(s==="json")i=JSON.parse(o);else if(s==="yaml"||s==="yml")i=R.parse(o);else throw new Error("Invalid config file format");n?.debug?.heading.log("The Config Object"),n?.debug?.log(i);const a={value:""};if(z(i,a))return i;throw new Error(a.value)}p(X,"getServiceConfig");const Y=["\u280B","\u2819","\u2839","\u2838","\u283C","\u2834","\u2826","\u2827","\u2807","\u280F"],m={success:"\u2713",fail:"\u2717",spinning:Y};class q{static{p(this,"ConsoleWriter")}tasks=new Map;entries=[];truncate=0;intervalId=null;spinnerInterval=80;lastRender="";isRendering=!1;inline=!0;constructor(t={}){this.truncate=t.truncate??0,this.inline=t.inline??!0}startSpinner(){this.intervalId===null&&(this.intervalId=setInterval(()=>{[...this.tasks.values()].some(n=>n.status===u.Running)&&this.renderTasks()},this.spinnerInterval))}stopSpinner(){this.intervalId!==null&&(clearInterval(this.intervalId),this.intervalId=null)}renderTasks(){if(this.isRendering)return;if(this.isRendering=!0,this.inline&&this.lastRender){const i=this.lastRender.split(`
`).length;T.moveCursor(process.stdout,0,-i+1),T.clearScreenDown(process.stdout)}const t=[...this.tasks.values()],n=t.filter(i=>i.status===u.Running),o=t.filter(i=>i.status===u.Success||i.status===u.Fail);if(n.length===0&&o.length>0){let i="";for(const a of o){if(a.status===u.Success){const f=l.green(m.success);i+=`${f} ${a.text}
`}else if(a.status===u.Fail){const f=l.red(m.fail);i+=`${f} ${a.text}
`}this.tasks.delete(a.id)}console.log(i)}for(const i of this.entries){const{level:a,time:f,kind:c,payload:h}=i;c==="heading"?Z(a,h,{truncate:this.truncate}):tt(a,h,{truncate:this.truncate})}this.entries=[];let s="";for(const i of this.tasks.values())if(i.status===u.Running){const a=l.cyan(m.spinning[i.frameIndex]);i.frameIndex=(i.frameIndex+1)%m.spinning.length,s+=`${a} ${i.text}
`}else if(i.status===u.Success){const a=l.green(m.success);s+=`${a} ${i.text}
`}else if(i.status===u.Fail){const a=l.red(m.fail);s+=`${a} ${i.text}
`}this.lastRender=s,process.stdout.write(s),this.isRendering=!1}handleEvent(t){const{level:n,time:o,payload:s}=t;if(s.length>0&&Q(s[0])){const a=s[0],{id:f,message:c,status:h}=a;if(h===u.Running)this.tasks.set(f,{id:f,text:c,status:h,frameIndex:0});else if((h===u.Success||h===u.Fail)&&this.tasks.has(f)){const C=this.tasks.get(f);C.status=h,C.text=c}}else this.entries.push(t);this.renderTasks();const i=[...this.tasks.values()].some(a=>a.status===u.Running);i&&this.intervalId===null?this.startSpinner():!i&&this.intervalId!==null&&this.stopSpinner()}destroy(){this.stopSpinner()}}function Q(e){if(typeof e!="object"||e===null)return!1;const t=e;if(t.type!=="task"||typeof t.id!="string"||typeof t.message!="string")return!1;switch(t.status){case u.Running:case u.Success:case u.PartialSuccess:case u.Fail:return!0;default:return!1}}p(Q,"isTask");function Z(e,t,n){let o,s;e===d.Error?(o=l.red,s=l.redBright.bold):e===d.Warn?(o=l.yellow,s=l.yellowBright.bold):e>=d.Info?(o=l.blue,s=l.whiteBright.bold):(o=l.gray,s=l.white);const{message:i,data:a}=S(t);console.log(`${o("==>")} ${s(i)}`),x(e,a,n)}p(Z,"heading");function tt(e,t,n){let o;e===d.Error?o=l.red:e===d.Warn?o=l.yellow:e>=d.Info?o=l.white:o=l.gray;const{message:s,data:i}=S(t);s&&console.log(o(s)),x(e,i,n)}p(tt,"body");const $="    ";function x(e,t,n){let o;e===d.Error?(o=l.red,n.truncate=0):e==d.Warn?o=l.yellow:e>=d.Info?o=l.white:o=l.gray,t.forEach(s=>{if(typeof s=="string"){console.log(o(`${$}${s}`));return}for(const[i,a]of Object.entries(s)){let f=JSON.stringify(a,et(n.truncate),"	");const c=`${i}: ${f}`.split(`
`).map(h=>$+h).join(`
`);console.log(o(c))}})}p(x,"values");function S(e){const[t,...n]=e;let o="",s=n;if(t){let{message:i,...a}=t;o=i&&typeof i=="string"?i:"",Object.keys(a).length>0&&(s=[a,...s])}return{message:o,data:s}}p(S,"toMsgData");function et(e){return e===0?null:(t,n)=>typeof n=="string"&&n.length>e?n.slice(0,e)+"<...>":n}p(et,"truncator");const y="./logs/";class nt{static{p(this,"LogWriter")}time;initialized=!1;pendingWrites=[];constructor(){this.time=new Date().toISOString()}get filename(){return`${y}${this.time}.log`}async initialize(){try{await N(y)}catch{await M(y)}const t=_(this.filename,`AXLE: New run at ${this.time}
`);this.pendingWrites.push(t);try{await t,this.initialized=!0}finally{const n=this.pendingWrites.indexOf(t);n!==-1&&this.pendingWrites.splice(n,1)}}async writeToLog(t){const{time:n,level:o,payload:s}=t;this.initialized||await this.initialize();const i=s.map(c=>typeof c=="string"?c:JSON.stringify(c)),a=`${d[o]} ${new Date(n).toISOString()} > ${i.join(" >> ")}
`,f=U(this.filename,a).catch(c=>{console.error(`Failed to write to log file: ${c}`)});this.pendingWrites.push(f);try{await f}finally{const c=this.pendingWrites.indexOf(f);c!==-1&&this.pendingWrites.splice(c,1)}}async handleEvent(t){await this.writeToLog(t)}async flush(){this.pendingWrites.length>0&&await Promise.all(this.pendingWrites)}}const b=new A().name("axle").description("A CLI tool for running AI jobs").version("1.0.0").option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("--no-log","Do not write the output to a log file").option("--no-warn-unused","Do not warn about unused variables").option("--no-inline","Do not inline the console output").option("-d, --debug","Print additional debug information").option("--truncate <num>","Truncate printed strings to a certain number of characters, 0 to disable",parseInt,100).option("--args <args...>","Additional arguments in the form key=value");b.parse(process.argv);const g=b.opts(),w={};g.args&&g.args.forEach(e=>{const[t,n]=e.split("=");t&&n&&(w[t.trim()]=n.trim())}),process.on("uncaughtException",async e=>{console.error("Uncaught exception:"),console.error(e),r&&(r.error?.log("Uncaught exception:"),r.error?.log(e.message),r.error?.log(e.stack||""),await r.shutdown()),process.exit(1)});const r=new D;g.debug&&(r.level=d.Debug);const it=new q(g);if(r.subscribe(it),g.log){const e=new nt;await e.initialize(),r.subscribe(e)}g.debug&&(r.debug?.heading.log("Options"),r.debug?.log(g),r.debug?.heading.log("Additional Arguments:"),r.debug?.log(w));let v,k;try{v=await X({configPath:g.config??null,options:g,recorder:r}),k=await H({path:g.job??null,options:g,recorder:r})}catch(e){r.error.log(e.message),r.error.log(e.stack),await r.shutdown(),b.outputHelp(),process.exit(1)}let F;try{const{engine:e,...t}=k.using,n={...v[e],...t};F=L(e,n)}catch(e){r.error.log(e.message),r.error.log(e.stack),await r.shutdown(),b.outputHelp(),process.exit(1)}P().setConfig(v),r.info?.heading.log("All systems operational. Running job...");const st=Date.now();g.dryRun&&r.info?.log("Dry run mode enabled. No API calls will be made.");const j={in:0,out:0},E=await J(k.jobs).execute({provider:F,variables:w,options:g,stats:j,recorder:r});E&&(r.info?.heading.log("Response"),r.info.log(E)),r.info?.heading.log("Usage"),r.info?.log(`Total run time: ${Date.now()-st}ms`),r.info?.log(`Input tokens: ${j.in} `),r.info?.log(`Output tokens: ${j.out} `),r.info?.heading.log("Complete. Goodbye"),await r.shutdown();
