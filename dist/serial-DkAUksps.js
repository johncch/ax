var q=Object.defineProperty;var a=(t,e)=>q(t,"name",{value:e,configurable:!0});import M from"@anthropic-ai/sdk";import H from"openai";import{serializeError as B}from"serialize-error";import{readFile as W,access as J,constants as K}from"fs/promises";import{glob as R}from"glob";import{readFile as v,writeFile as z,access as G,mkdir as X}from"node:fs/promises";import{resolve as A,dirname as Q}from"node:path";class y extends Error{static{a(this,"AxleError")}code;id;details;constructor(e,s){super(e,{cause:s?.cause}),this.name=this.constructor.name,this.code=s?.code||"AXLE_ERROR",this.id=s?.id,this.details=s?.details,Object.setPrototypeOf(this,y.prototype)}}var p=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(p||{});const Y={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},Z=Y.CLAUDE_3_5_HAIKU_LATEST;class V{static{a(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,s){this.model=s??Z,this.client=new M({apiKey:e})}createChatCompletionRequest(e){return new ee(this,e)}}class ee{static{a(this,"AnthropicChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toAnthropic(),max_tokens:te(o)};s?.debug?.log(n);let i;try{const c=await r.messages.create(n);i=se(c)}catch(c){i={type:"error",error:{type:c.error.error.type??"Undetermined",message:c.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:c}}return s?.debug?.log(i),i}}function te(t){switch(t){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}a(te,"getMaxTokens");function U(t){switch(t){case"max_tokens":return p.Length;case"end_turn":return p.Stop;case"stop_sequence":return p.Stop;case"tool_use":return p.FunctionCall;default:return p.Error}}a(U,"getStopReason$1");function se(t){const e=U(t.stop_reason);if(e===p.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===p.FunctionCall){const s=t.content[0],r=s.type==="text"?s.text:"",o=t.content.slice(1).map(n=>{if(n.type==="tool_use")return{id:n.id,name:n.name,arguments:n.input}}).filter(n=>n!==null);return{type:"success",id:t.id,model:t.model,reason:p.FunctionCall,message:{role:t.role,content:r,toolCalls:o},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:U(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}a(se,"translate$1");const re="http://localhost:11434";class ne{static{a(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,s){this.url=s||re,this.model=e}createChatCompletionRequest(e){return new oe(this.url,this.model,e)}}class oe{static{a(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,s,r){this.url=e,this.model=s,this.chat=r}async execute(e){const{recorder:s}=e,r={model:this.model,messages:this.chat.toOpenAI().messages,stream:!1,options:{temperature:.7}};s?.debug?.log(r);let o;try{const n=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const i=await n.json();o={type:"success",id:`ollama-${Date.now()}`,model:this.model,reason:p.Stop,message:{role:"assistant",content:i.message?.content||""},usage:{in:i.prompt_eval_count||0,out:i.eval_count||0},raw:i}}catch(n){s?.error?.log("Error fetching Ollama response:",n),o={type:"error",error:{type:"OllamaError",message:n.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(n)}}return s?.debug?.log(o),o}}const ae={GPT_4_1:"gpt-4.1"},ie=ae.GPT_4_1;class ce{static{a(this,"OpenAIProvider")}constructor(e,s){this.apiKey=e,this.model=s||ie,this.client=new H({apiKey:e})}name="OpenAI";client;model;createChatCompletionRequest(e){return new ue(this,e)}}class ue{static{a(this,"OpenAIChatCompletionRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toOpenAI()};s?.debug?.log(n);let i;try{const c=await r.chat.completions.create(n);i=he(c)}catch(c){s?.error?.log(c),i={type:"error",error:{type:c.type??"Undetermined",message:c.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:c}}return s?.debug?.log(i),i}}function le(t){switch(t){case"length":return p.Length;case"stop":return p.Stop;case"tool_calls":return p.FunctionCall;default:return p.Error}}a(le,"getStopReason");function he(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(r=>({id:r.id,name:r.function.name,arguments:r.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:le(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}a(he,"translate");function pe(t,e){switch(t){case"openai":return new ce(e["api-key"],e.model);case"anthropic":return new V(e["api-key"],e.model);case"ollama":{const s=e;return new ne(s.model,s.url)}default:throw new y("The provider is unsupported")}}a(pe,"getProvider");class F extends y{static{a(this,"TaskError")}constructor(e,s){super(e,{code:"TASK_ERROR",id:s?.id,details:{taskType:s?.taskType,taskIndex:s?.taskIndex,...s?.details},cause:s?.cause}),Object.setPrototypeOf(this,F.prototype)}}const x={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var g=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(g||{});class de{static{a(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=g.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=g.Debug>=this.currentLevel?this.createLoggingFunction(g.Debug):null,this._info=g.Info>=this.currentLevel?this.createLoggingFunction(g.Info):null,this._warn=g.Warn>=this.currentLevel?this.createLoggingFunction(g.Warn):null,this._error=this.createLoggingFunction(g.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s,...r){let o=r.map(n=>typeof n=="string"?{message:n}:n instanceof Error?B(n):n);this.publish({level:e,time:Date.now(),kind:s,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=g.Info){return this.logs.filter(s=>s.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}class me{static{a(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}toOpenAI(){const e=[];this.system&&e.push({role:"system",content:this.system});const s=this.tools.length>0?this.tools.map(o=>({type:"function",function:o})):void 0,r=this.messages.map(o=>{switch(o.role){case"tool":return o.content.map(n=>({role:"tool",tool_call_id:n.id,content:n.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(n=>({id:n.id,type:"function",function:{name:n.name,arguments:JSON.stringify(n.arguments)}}))};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...r],...s&&{tools:s}}}toAnthropic(){const e=this.messages.map(r=>{switch(r.role){case"assistant":const o=[];return o.push({type:"text",text:r.content}),r.toolCalls&&o.push(...r.toolCalls.map(n=>({type:"tool_use",id:n.id,name:n.name,input:n.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:r.content.map(n=>({type:"tool_result",tool_use_id:n.id,content:n.content}))};default:return{role:"user",content:r.content}}}),s=this.tools.map(r=>({name:r.name,description:r.description,input_schema:r.parameters}));return{system:this.system,messages:e,tools:s}}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}async function ge({path:t,defaults:e,loader:s="File"}){let r=null,o="";if(t)try{o=A(t),r=await v(o,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const n of e.formats)try{o=A(e.name+"."+n),r=await v(o,{encoding:"utf-8"});break}catch{continue}if(r===null)throw new Error(`${s} not found, see --help for details`)}return{content:r,format:o.split(".").pop()??""}}a(ge,"loadFile");async function fe(t,e){let s="";for(const r of t){const o=await R(r);e?.debug?.log(`many-files parser. For glob "${r}", found ${o.length} files.`);const n=await Promise.all(o.map(async i=>{const c=await v(i,"utf-8");return i+`:
`+c}));s+=n.join(`
`)}return s}a(fe,"loadManyFiles");function ye(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,r=t.match(s);if(r){let o="";return r.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,r.groups?.extension?o+=r.groups.extension:o+=e.ext,t.replace(r[0],o)}return t}a(ye,"replaceFilePattern");function we(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}a(we,"pathToComponents");async function P(t){const e=Q(t);try{await G(e)}catch{await X(e),await P(e)}}a(P,"ensureDirectoryExistence");async function be({filePath:t,content:e}){await P(t),await z(t,e)}a(be,"writeFileWithDirectories");class ke{static{a(this,"FileRunPlanner")}constructor(e,s,r=[]){this.source=e,this.bind=s,this.skipConditions=r}async plan(e){const s=[],r=await R(this.source,{withFileTypes:!0});for(const o of r){const n=o.fullpath(),i=we(n);let c=!1;for(const u of this.skipConditions)if(c=await u.eval({components:i}),c)break;if(!c){const u=await W(n,"utf-8"),h={variables:{[this.bind]:u,...i},tasks:e};s.push(h)}}return s}}class Te{static{a(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async o=>await o.plan(e));return(await Promise.all(s)).flat()}}function S(t,e,s="{{}}"){const r=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(r,(o,n)=>e[n]?e[n]:o),t}a(S,"replaceVariables");class xe{static{a(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=S(this.pattern,e.components,"{}");try{return await J(s,K.F_OK),!0}catch{return!1}}}var k=(t=>(t.String="string",t.List="string[]",t.Number="number",t.Boolean="boolean",t))(k||{});const Ee={response:k.String};class _{static{a(this,"Instruct")}type="instruct";_result=void 0;prompt;system=null;inputs={};tools={};resFormat;rawResponse;constructor(e,s){this.prompt=e,this.resFormat=s}static with(e,s){return s?new _(e,s):new _(e,Ee)}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}get result(){return this._result}compile(e,s={}){const{recorder:r,options:o}=s,n={...e,...this.inputs};let i=S(this.prompt,n);if(o?.warnUnused){const c=i.match(/\{\{(.*?)\}\}/g);if(c)throw r?.error.log(`Warning unused variables ${c.join(", ")}`),new Error(`Unused variables: ${c.join(", ")}`)}return i+=`
The answer must be enclosed in the following XML tags: ${Object.keys(this.resFormat).join(", ")}`,i}finalize(e){this.rawResponse=e;const s={},r=Object.keys(this.resFormat);if(r.length===0){if(e.trim()==="{}"||e.trim()==="")return{};throw new Error("Output format is empty, but rawValue is not an empty object representation or empty string.")}const o=_e(e);for(const n of r){const i=n;let c;const u=o.tags[i];if(u)c=u;else if(r.length===1)c=o.remaining;else throw new Error(`Expected results with tag ${i} but it does not exist`);const h=this.resFormat[n];try{const l=Ce(h,c);s[n]=l}catch(l){throw new Error(`Cannot convert value of key ${i} to ${h}: ${l.message}`)}}return this._result=s,s}}function _e(t){const e=/<(\w+)>(.*?)<\/\1>/gs,s={};let r=t;return r=r.replace(e,(o,n,i)=>(s[n]=i,"")),{tags:s,remaining:r.trim()}}a(_e,"parseTaggedSections");function Ce(t,e){let s;switch(t){case k.String:s=e;break;case k.Number:if(s=parseFloat(e),isNaN(s))throw new Error(`Cannot parse '${e}' as number. Expected a numeric string.`);break;case k.Boolean:const r=e.toLowerCase();if(r==="true")s=!0;else if(r==="false")s=!1;else throw new Error(`Cannot parse '${e}' as boolean. Expected 'true' or 'false'.`);break;case k.List:e===""?s=[]:s=e.split(",").map(o=>o.trim());break}return s}a(Ce,"typeResponses");function $e(t){return Array.isArray(t)?t:[t]}a($e,"arrayify");function $(t){return t.slice(0,8)}a($,"friendly");function ve(t){return new Promise(e=>setTimeout(e,t))}a(ve,"delay");const Se={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class Oe{static{a(this,"BraveSearchTool")}name="brave";schema=Se;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:s}=e;this.apiKey=e["api-key"],this.throttle=s?1100/s:void 0}async execute(e,s={}){const{searchTerm:r}=e,{recorder:o}=s;if(o?.debug?.heading.log(`Brave: searching for ${r}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await ve(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const n=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",c=new URL(i);c.searchParams.append("q",r),c.searchParams.append("format","json");const u=await fetch(c.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":n}});if(!u.ok)throw new Error(`[Brave] HTTP error ${u.status}: ${u.statusText}`);return await u.json()}catch(n){throw o?.error.log("[Brave] Error fetching search results:",n),n}}}const Fe=new Oe,Re={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Ae={name:"calculator",schema:Re,execute:a(async t=>{const{operation:e,a:s,b:r}=t;switch(e){case"add":return`${s} + ${r} = ${s+r}`;case"subtract":return`${s} - ${r} = ${s-r}`;case"multiply":return`${s} * ${r} = ${s*r}`;case"divide":if(r===0)throw new Error("Cannot divide by zero");return`${s} / ${r} = ${s/r}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class Ue{static{a(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let E;function L(){return E||(E=new Ue,E.register(Ae),E.register(Fe)),E}a(L,"getToolRegistry");const Pe={async convert(t,e){const{recorder:s,toolNames:r}=e,{message:o,system:n,replace:i}=t,c=_.with(o);n&&(c.system=n);const u=[...new Set([...r??[],...t.tools??[]])];for(const h of u){const l=L().get(h);c.addTool(l)}if(i){for(const h of i)if(h.source==="file"){const l=$e(h.files),m=await fe(l,s);c.addInput(h.pattern,m)}}return c}};class Le{static{a(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}const De={async convert(t){return{type:"write-to-disk",output:t.output}}},O=new Le;O.register("write-to-disk",De),O.register("chat",Pe);async function D(t,e){const{recorder:s}=e,r=t.tools??void 0,o=t.steps.map(async n=>(n.uses,await O.get(n.uses).convert(n,{recorder:s,toolNames:r})));return Promise.all(o)}a(D,"configToTasks");async function je(t,e){const{batch:s}=t;return s.length===1?j(s[0]):new Te(s.map(r=>j(r)))}a(je,"configToPlanner");function j(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(r=>Ie(r))),new ke(t.source,t.bind,e)}}a(j,"batchOptionsToPlanner");function Ie(t){switch(t.type){case"file-exist":return new xe(t.pattern)}}a(Ie,"skipOptionsToSkipConditions");var b=(t=>(t.Latest="latest",t.LastResult="lastResult",t))(b||{});class Ne{static{a(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:r,options:o={},recorder:n}=e;if(o.dryRun){n?.debug?.log("Dry run: no action was taken");return}const i=s.output,c=r[b.Latest];if(typeof c=="string"){let u="";i.includes("*")?u=ye(i,r.file):u=S(i,r,"{}"),await be({filePath:u,content:c})}}}class qe{static{a(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...r}=e;await Me({instruct:s,...r})}}async function Me(t){const{instruct:e,chat:s,provider:r,stats:o,variables:n,options:i,recorder:c}=t;if(e.system&&s.addSystem(e.system),s.addUser(e.compile(n,{recorder:c,options:i})),e.hasTools()){const h=Be(e.tools);s.setToolSchemas(h)}if(i?.dryRun)return c?.debug?.log(s),{action:"complete"};let u=!0;for(;u;){const l=await r.createChatCompletionRequest(s).execute({recorder:c});if(o.in+=l.usage.in,o.out+=l.usage.out,l.type==="error")throw new Error(l.error.message);if(l.type==="success")switch(l.reason){case p.Stop:{if(l.message.content){const m=l.message.content;s.addAssistant(m);const d=e.finalize(m);for(const[f,w]of Object.entries(d))n[f]=w;n[b.LastResult]=d,n[b.Latest]=l.message.content}return u=!1,{action:"continue"}}case p.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case p.FunctionCall:{let m=l.message;if(l.message&&(s.addAssistant(m.content,m.toolCalls),n[b.Latest]=l.message.content),m.toolCalls&&m.toolCalls.length>0){const d=await He(m.toolCalls,e);c?.debug?.log(d);const f=d.map(w=>({id:w.id,content:JSON.stringify(w.results)}));s.addTools(f),u=!0}else u=!1;break}}if(l.type!=="success")throw c?.debug?.log(l),new Error("Unexpected response type")}return{action:"continue"}}a(Me,"executeChatAction");async function He(t,e){const s=[];for(const r of t)s.push(new Promise((o,n)=>{const i=e.tools[r.name];if(!i){n(`Tool not found: ${r.name}`);return}let c={};try{const u=JSON.parse(r.arguments);u&&typeof u=="object"&&!Array.isArray(u)&&(c=u)}catch{n(`argument for tool ${r.name} is not valid: ${JSON.stringify(r.arguments)}`)}i.execute(c).then(u=>o({id:r.id,results:u})).catch(n)}));return Promise.all(s)}a(He,"executeToolCalls");function Be(t){const e=[];for(const[s,r]of Object.entries(t))e.push(r.schema);return e}a(Be,"getToolSchemas");class We{static{a(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,r=s.type,o=this.getHandler(s);if(!o)throw new Error(`No handler registered for action type: ${r}`);if(!o.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${r}`);await o.execute(e)}}function Je(){const t=new We;return t.register(new qe),t}a(Je,"createBaseRegistry");function Ke(){const t=Je();return t.register(new Ne),t}a(Ke,"createNodeRegistry");function ze(t){return t.success===!1&&t.error!==void 0}a(ze,"isErrorResult");function I(t,e){return{response:t,stats:e,success:!0}}a(I,"createResult");function N(t,e,s){return{response:e,stats:s,error:t,success:!1}}a(N,"createErrorResult");const Ge=a((t,...e)=>{const s=a(async o=>{const{recorder:n}=o;let i=[];return"type"in t&&t.type==="serial"?i=await D(t,{recorder:n}):i=[t,...e],i},"prepare");return{execute:a(async o=>{const{provider:n,variables:i,options:c,stats:u,recorder:h}=o,l=crypto.randomUUID(),m=Ke();h?.info?.log({type:"task",id:l,status:x.Running,message:`[${$(l)}] Starting job`});try{const d=await s({recorder:h}),f=new me;for(const[w,C]of d.entries()){h?.info?.log({type:"task",id:l,status:x.Running,message:`[${$(l)}] Processing step ${w+1}: ${C.type}`});try{await m.executeTask({task:C,chat:f,provider:n,variables:i,options:c,stats:u,recorder:h})}catch(T){throw T instanceof y?T:new F(`Error executing task ${C.type}`,{id:l,taskType:C.type,taskIndex:w,cause:T instanceof Error?T:new Error(String(T))})}}return h?.info?.log({type:"task",status:x.Success,id:l,message:`[${$(l)}] Completed ${d.length} steps`}),I(i[b.LastResult],u)}catch(d){const f=d instanceof y?d:new y("Serial workflow execution failed",{id:l,cause:d instanceof Error?d:new Error(String(d))});return h?.info?.log({type:"task",status:x.Fail,id:l,message:`[${$(l)}] Failed: ${f.message}`}),h?.error.log(f),N(f,i[b.LastResult],u)}},"execute")}},"serialWorkflow");export{y as A,_ as I,g as L,de as R,x as T,N as a,je as b,I as c,D as d,L as e,pe as g,ze as i,ge as l,Ge as s};
