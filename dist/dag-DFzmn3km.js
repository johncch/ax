var re=Object.defineProperty;var c=(t,e)=>re(t,"name",{value:e,configurable:!0});import oe from"@anthropic-ai/sdk";import{GoogleGenAI as ie,Type as ae,FinishReason as v}from"@google/genai";import ce from"openai";import{serializeError as ue}from"serialize-error";import{readFile as le,access as fe,constants as pe}from"fs/promises";import{glob as K}from"glob";import{readFile as M,writeFile as de,access as ge,mkdir as he}from"node:fs/promises";import{resolve as z,dirname as me}from"node:path";class m extends Error{static{c(this,"AxleError")}code;id;details;constructor(e,s){super(e,{cause:s?.cause}),this.name=this.constructor.name,this.code=s?.code||"AXLE_ERROR",this.id=s?.id,this.details=s?.details,Object.setPrototypeOf(this,m.prototype)}}var g=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(g||{});const ye={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},we=ye.CLAUDE_3_5_HAIKU_LATEST;class ve{static{c(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,s){this.model=s??we,this.client=new oe({apiKey:e})}createChatCompletionRequest(e){return new ke(this,e)}}class ke{static{c(this,"AnthropicChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r={model:o,...$e(this.chat),max_tokens:be(o)};s?.debug?.log(r);let i;try{const a=await n.messages.create(r);i=xe(a)}catch(a){i={type:"error",error:{type:a.error.error.type??"Undetermined",message:a.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}}function be(t){switch(t){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}c(be,"getMaxTokens");function X(t){switch(t){case"max_tokens":return g.Length;case"end_turn":return g.Stop;case"stop_sequence":return g.Stop;case"tool_use":return g.FunctionCall;default:return g.Error}}c(X,"getStopReason$2");function $e(t){const e=t.messages.map(n=>{switch(n.role){case"assistant":const o=[];return o.push({type:"text",text:n.content}),n.toolCalls&&o.push(...n.toolCalls.map(r=>({type:"tool_use",id:r.id,name:r.name,input:r.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:n.content.map(r=>({type:"tool_result",tool_use_id:r.id,content:r.content}))};default:return{role:"user",content:n.content}}}),s=t.tools.map(n=>({name:n.name,description:n.description,input_schema:n.parameters}));return{system:t.system,messages:e,tools:s}}c($e,"prepareRequest$2");function xe(t){const e=X(t.stop_reason);if(e===g.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===g.FunctionCall){const s=t.content[0],n=s.type==="text"?s.text:"",o=t.content.slice(1).map(r=>{if(r.type==="tool_use")return{id:r.id,name:r.name,arguments:r.input}}).filter(r=>r!==null);return{type:"success",id:t.id,model:t.model,reason:g.FunctionCall,message:{role:t.role,content:n,toolCalls:o},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:X(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}c(xe,"translate");const Te={GEMINI_2_5_FLASH_PREVIEW:"gemini-2.5-flash-preview-05-20"},Ee=Te.GEMINI_2_5_FLASH_PREVIEW;class Ce{static{c(this,"GoogleAIProvider")}name="GoogleAI";client;model;constructor(e,s){this.model=s??Ee,this.client=new ie({apiKey:e})}createChatCompletionRequest(e){return new Ae(this,e)}}class Ae{static{c(this,"GoogleAIChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r=this.prepareRequest(this.chat);s?.debug?.log(r);let i;try{const a=await n.models.generateContent({model:o,...r});i=Se(a,e)}catch(a){s?.error?.log(a),i={type:"error",error:{type:a.name??"Undetermined",message:a.message??"Unexpected error from Google AI"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}prepareRequest(e){let s;e.messages.length===1&&e.messages[0].role=="user"?s=e.messages[0].content:s=e.messages.map(o=>{if(o.role==="user")return{role:"user",parts:[{text:o.content}]};if(o.role==="assistant"){const r={role:"assistant",parts:[]};return o.content&&r.parts.push({text:o.content}),o.toolCalls&&(r.parts=r.parts.concat(o.toolCalls.map(i=>{let a;return typeof i.arguments=="string"?a=JSON.parse(i.arguments):a=i.arguments,{functionCall:{id:i.id??void 0,name:i.name,args:a}}}))),r}else if(o.role==="tool")return{role:"user",parts:o.content.map(r=>({functionResponse:{id:r.id??void 0,name:r.name,response:{output:r.content}}}))}});const n={};return e.system&&(n.systemInstruction=e.system),e.tools.length>0&&(n.tools=e.tools.map(o=>({functionDeclarations:[{name:o.name,description:o.description,parameters:{...o.parameters,type:ae.OBJECT}}]}))),{contents:s,config:n}}}function Se(t,e){const{recorder:s}=e,n=t.usageMetadata.promptTokenCount,o=t.usageMetadata.totalTokenCount-n,r={in:n,out:o};if(!t)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};if(t.promptFeedback&&t.promptFeedback.blockReason)return{type:"error",error:{type:"Blocked",message:`Response blocked by Google AI: ${t.promptFeedback.blockReason}, ${t.promptFeedback.blockReasonMessage}`},usage:r,raw:t};if(!t.candidates||t.candidates.length===0)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};t.candidates.length>1&&s?.warn?.log(`We received ${t.candidates.length} response candidates`);const i=t.candidates[0],u=(i.content?.parts||[]).map(p=>p.text).filter(p=>p!==void 0).join(""),[l,f]=_e(i.finishReason);if(l){let p;return t.functionCalls&&(p=t.functionCalls.map(d=>({id:d.id,name:d.name,arguments:JSON.stringify(d.args)}))),{type:"success",id:t.responseId,model:t.modelVersion,reason:t.functionCalls?g.FunctionCall:f,message:{role:"assistant",...u?{content:u}:{},...p?{toolCalls:p}:{}},usage:r,raw:t}}else return{type:"error",error:{type:"Undetermined",message:`Unexpected stop reason: ${f}`},usage:r,raw:t}}c(Se,"translateResponse$2");function _e(t){switch(t){case v.STOP:return[!0,g.Stop];case v.MAX_TOKENS:return[!0,g.Length];case v.FINISH_REASON_UNSPECIFIED:case v.SAFETY:case v.RECITATION:case v.LANGUAGE:case v.OTHER:case v.BLOCKLIST:case v.PROHIBITED_CONTENT:case v.SPII:case v.MALFORMED_FUNCTION_CALL:case v.IMAGE_SAFETY:return[!1,g.Error]}}c(_e,"getStopReason$1");const Re="http://localhost:11434";class Oe{static{c(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,s){this.url=s||Re,this.model=e}createChatCompletionRequest(e){return new Pe(this.url,this.model,e)}}class Pe{static{c(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,s,n){this.url=e,this.model=s,this.chat=n}async execute(e){const{recorder:s}=e,n={model:this.model,stream:!1,options:{temperature:.7},...Fe(this.chat)};s?.debug?.log(n);let o;try{const r=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!r.ok)throw console.log(r),new Error(`HTTP error! status: ${r.status}`);const i=await r.json();o=Ie(i)}catch(r){s?.error?.log("Error fetching Ollama response:",r),o={type:"error",error:{type:"OllamaError",message:r.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(r)}}return s?.debug?.log(o),o}}function Fe(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,n=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(r=>({role:"tool",tool_call_id:r.id,content:r.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(r=>{const i=r.id;return{type:"function",function:{name:r.name,arguments:r.arguments},...i&&{id:i}}})};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...n],...s&&{tools:s}}}c(Fe,"prepareRequest$1");function Ie(t){if(t.done_reason==="stop"&&t.message){const e=t.message.content,s=[];if(t.message.tool_calls)for(const o of t.message.tool_calls)s.push({id:o.id,name:o.function.name,arguments:o.function.arguments});const n=s.length>0;return{type:"success",id:`ollama-${Date.now()}`,model:t.model,reason:n?g.FunctionCall:g.Stop,message:{role:"assistant",content:e,...n&&{toolCalls:s}},usage:{in:t.prompt_eval_count||0,out:t.eval_count||0},raw:t}}return{type:"error",error:{type:"OllamaError",message:"Unexpected error from Ollama"},usage:{in:0,out:0},raw:t}}c(Ie,"translateResponse$1");const De={GPT_4_1:"gpt-4.1"},Ne=De.GPT_4_1;class Ue{static{c(this,"OpenAIProvider")}constructor(e,s){this.apiKey=e,this.model=s||Ne,this.client=new ce({apiKey:e})}name="OpenAI";client;model;createChatCompletionRequest(e){return new Le(this,e)}}class Le{static{c(this,"OpenAIChatCompletionRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:n,model:o}=this.provider,r={model:o,...We(this.chat)};s?.debug?.log(r);let i;try{const a=await n.chat.completions.create(r);i=qe(a)}catch(a){s?.error?.log(a),i={type:"error",error:{type:a.type??"Undetermined",message:a.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:a}}return s?.debug?.log(i),i}}function Me(t){switch(t){case"length":return g.Length;case"stop":return g.Stop;case"tool_calls":return g.FunctionCall;default:return g.Error}}c(Me,"getStopReason");function We(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,n=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(r=>({role:"tool",tool_call_id:r.id,content:r.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(r=>{const i=r.id;return{type:"function",function:{name:r.name,arguments:typeof r.arguments=="string"?r.arguments:JSON.stringify(r.arguments)},...i&&{id:i}}})};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...n],...s&&{tools:s}}}c(We,"prepareRequest");function qe(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(n=>({id:n.id,name:n.function.name,arguments:n.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:Me(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}c(qe,"translateResponse");function Ge(t,e){if(!e||Object.keys(e).length===0)throw new m(`The provider ${t} is not configured. Please check your configuration.`);switch(t){case"openai":return new Ue(e["api-key"],e.model);case"anthropic":return new ve(e["api-key"],e.model);case"google":return new Ce(e["api-key"],e.model);case"ollama":{const s=e;return new Oe(s.model,s.url)}default:throw new m("The provider is unsupported")}}c(Ge,"getProvider");class H extends m{static{c(this,"TaskError")}constructor(e,s){super(e,{code:"TASK_ERROR",id:s?.id,details:{taskType:s?.taskType,taskIndex:s?.taskIndex,...s?.details},cause:s?.cause}),Object.setPrototypeOf(this,H.prototype)}}const w={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var b=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(b||{});class Be{static{c(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=b.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=b.Debug>=this.currentLevel?this.createLoggingFunction(b.Debug):null,this._info=b.Info>=this.currentLevel?this.createLoggingFunction(b.Info):null,this._warn=b.Warn>=this.currentLevel?this.createLoggingFunction(b.Warn):null,this._error=this.createLoggingFunction(b.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s,...n){let o=n.map(r=>typeof r=="string"?{message:r}:r instanceof Error?ue(r):r);this.publish({level:e,time:Date.now(),kind:s,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=b.Info){return this.logs.filter(s=>s.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}function He(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):Je(t.using,e)?!t.jobs||typeof t.jobs!="object"?(e&&(e.value="Missing or invalid 'jobs' property"),!1):Y(t.jobs,e)?!0:(e&&(e.value=`Invalid 'jobs' property: ${e?.value}`),!1):(e&&(e.value=`Invalid 'using' property: ${e?.value}`),!1)}c(He,"isJobConfig");function Je(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(typeof t.engine!="string")return e&&(e.value="Missing or invalid 'engine' property"),!1;if(!["openai","anthropic","ollama","google"].includes(t.engine))return e&&(e.value="Invalid provider type. Must be 'openai', 'anthropic', 'google', or 'ollama'"),!1;switch(t.engine){case"ollama":if("model"in t&&typeof t.model!="string")return e&&(e.value="Property 'model' must be a string"),!1;if("url"in t&&typeof t.url!="string")return e&&(e.value="Property 'url' must be a string"),!1;break;case"google":case"anthropic":case"openai":if("api-key"in t&&typeof t["api-key"]!="string")return e&&(e.value="Property 'api-key' must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Property 'model' must be a string"),!1;break}return!0}c(Je,"isUsing");function Y(t,e){for(const[s,n]of Object.entries(t))if(!Ke(n,e))return e&&(e.value=`Invalid job '${s}': ${e?.value}`),!1;return!0}c(Y,"isDAGJob");function Ke(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(!ze(t,e))return!1;if("dependsOn"in t&&t.dependsOn!==void 0){const s=t.dependsOn;if(typeof s!="string")if(Array.isArray(s)){for(let n=0;n<s.length;n++)if(typeof s[n]!="string")return e&&(e.value=`Dependency at index ${n} must be a string`),!1}else return e&&(e.value="Property 'dependsOn' must be a string or array of strings"),!1}return!0}c(Ke,"isDAGJobValue");function ze(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):"batch"in t?Ye(t,e):Xe(t,e)}c(ze,"isJob");function Xe(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if("batch"in t)return e&&(e.value="Serial job should not have a batch property"),!1;if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}if(!Array.isArray(t.steps))return e&&(e.value="Property 'steps' must be an array"),!1;for(let s=0;s<t.steps.length;s++)if(!Q(t.steps[s],e))return e&&(e.value=`Invalid step at index ${s}: ${e?.value}`),!1;return!0}c(Xe,"isSerialJob");function Ye(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}if(!Array.isArray(t.batch))return e&&(e.value="Property 'batch' must be an array"),!1;for(let s=0;s<t.batch.length;s++){const n=t.batch[s];if(!n||typeof n!="object")return e&&(e.value=`Batch item at index ${s} must be an object`),!1;if(n.type!=="files")return e&&(e.value=`Batch item at index ${s} must have type 'files'`),!1;if(typeof n.source!="string")return e&&(e.value=`Batch item at index ${s} must have a string 'source' property`),!1;if(typeof n.bind!="string")return e&&(e.value=`Batch item at index ${s} must have a string 'bind' property`),!1;if(n["skip-if"]!==void 0){if(!Array.isArray(n["skip-if"]))return e&&(e.value=`Batch item at index ${s} must have an array 'skip-if' property`),!1;for(let o=0;o<n["skip-if"].length;o++)if(!Qe(n["skip-if"][o],e))return e&&(e.value=`Invalid skip condition at index ${o} in batch item ${s}: ${e?.value}`),!1}}if(!Array.isArray(t.steps))return e&&(e.value="Property 'steps' must be an array"),!1;for(let s=0;s<t.steps.length;s++)if(!Q(t.steps[s],e))return e&&(e.value=`Invalid step at index ${s}: ${e?.value}`),!1;return!0}c(Ye,"isBatchJob");function Qe(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):t.type!=="file-exist"?(e&&(e.value="Property 'type' must be 'file-exist'"),!1):typeof t.pattern!="string"?(e&&(e.value="Property 'pattern' must be a string"),!1):!0}c(Qe,"isSkipOptions");function Q(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):!t.uses||typeof t.uses!="string"?(e&&(e.value="Step must have a string 'uses' property"),!1):t.uses==="chat"?Ze(t,e):t.uses==="write-to-disk"?je(t,e):(e&&(e.value=`Unknown uses type: ${t.uses}`),!1)}c(Q,"isStep");function Ze(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(t.uses!=="chat")return e&&(e.value="Uses must be 'chat'"),!1;if(typeof t.message!="string")return e&&(e.value="Property 'message' must be a string"),!1;if(t.output!==void 0){if(!t.output||typeof t.output!="object"||Array.isArray(t.output))return e&&(e.value="Property 'output' must be an object"),!1;const s=["string","string[]","number","boolean"];for(const[n,o]of Object.entries(t.output))if(typeof n!="string"||typeof o!="string"||!s.includes(o))return e&&(e.value="Property 'output' must be a Record<string, ResTypeStrings> where ResTypeStrings is 'string' | 'string[]' | 'number' | 'boolean'"),!1}if(t.system!==void 0&&typeof t.system!="string")return e&&(e.value="Property 'system' must be a string"),!1;if(t.replace!==void 0){if(!Array.isArray(t.replace))return e&&(e.value="Property 'replace' must be an array"),!1;for(let s=0;s<t.replace.length;s++)if(!Ve(t.replace[s],e))return e&&(e.value=`Invalid replace at index ${s}: ${e?.value}`),!1}if(t.tools!==void 0){if(!Array.isArray(t.tools))return e&&(e.value="Property 'tools' must be an array"),!1;for(const s of t.tools)if(typeof s!="string")return e&&(e.value="All tools must be strings"),!1}return!0}c(Ze,"isChatStep");function je(t,e){return!t||typeof t!="object"?(e&&(e.value="Not an object"),!1):t.uses!=="write-to-disk"?(e&&(e.value="Uses must be 'write-to-disk'"),!1):typeof t.output!="string"?(e&&(e.value="Property 'output' must be a string"),!1):!0}c(je,"isWriteToDiskStep");function Ve(t,e){if(!t||typeof t!="object")return e&&(e.value="Not an object"),!1;if(typeof t.pattern!="string")return e&&(e.value="Property 'pattern' must be a string"),!1;if(t.source!=="file")return e&&(e.value="Property 'source' must be 'file'"),!1;if(typeof t.files!="string"&&!Array.isArray(t.files))return e&&(e.value="Property 'files' must be a string or an array of strings"),!1;if(Array.isArray(t.files)){for(let s=0;s<t.files.length;s++)if(typeof t.files[s]!="string")return e&&(e.value=`Files entry at index ${s} must be a string`),!1}return!0}c(Ve,"isReplace");async function et({path:t,defaults:e,loader:s="File"}){let n=null,o="";if(t)try{o=z(t),n=await M(o,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const r of e.formats)try{o=z(e.name+"."+r),n=await M(o,{encoding:"utf-8"});break}catch{continue}if(n===null)throw new Error(`${s} not found, see --help for details`)}return{content:n,format:o.split(".").pop()??""}}c(et,"loadFile");async function tt(t,e){let s="";for(const n of t){const o=await K(n);e?.debug?.log(`many-files parser. For glob "${n}", found ${o.length} files.`);const r=await Promise.all(o.map(async i=>{const a=await M(i,"utf-8");return i+`:
`+a}));s+=r.join(`
`)}return s}c(tt,"loadManyFiles");function st(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,n=t.match(s);if(n){let o="";return n.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,n.groups?.extension?o+=n.groups.extension:o+=e.ext,t.replace(n[0],o)}return t}c(st,"replaceFilePattern");function nt(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}c(nt,"pathToComponents");async function Z(t){const e=me(t);try{await ge(e)}catch{await he(e),await Z(e)}}c(Z,"ensureDirectoryExistence");async function rt({filePath:t,content:e}){await Z(t),await de(t,e)}c(rt,"writeFileWithDirectories");class ot{static{c(this,"FileRunPlanner")}constructor(e,s,n=[]){this.source=e,this.bind=s,this.skipConditions=n}async plan(e){const s=[],n=await K(this.source,{withFileTypes:!0});for(const o of n){const r=o.fullpath(),i=nt(r);let a=!1;for(const u of this.skipConditions)if(a=await u.eval({components:i}),a)break;if(!a){const u=await le(r,"utf-8"),l={variables:{[this.bind]:u,...i},tasks:e};s.push(l)}}return s}}class it{static{c(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async o=>await o.plan(e));return(await Promise.all(s)).flat()}}function W(t,e,s="{{}}"){const n=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(n,(o,r)=>e[r]?e[r]:o),t}c(W,"replaceVariables");class at{static{c(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=W(this.pattern,e.components,"{}");try{return await fe(s,pe.F_OK),!0}catch{return!1}}}var T=(t=>(t.String="string",t.List="string[]",t.Number="number",t.Boolean="boolean",t))(T||{});const j={response:T.String};class V{static{c(this,"AbstractInstruct")}type="instruct";_result=void 0;prompt;system=null;inputs={};tools={};resFormat;rawResponse;finalPrompt;constructor(e,s){this.prompt=e,this.resFormat=s}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}get result(){return this._result}compile(e,s={}){const n=this.getFinalUserPrompt(e,s),o=this.getFormatInstructions();return n+`
`+o}getFinalUserPrompt(e,s={}){const{recorder:n,options:o}=s,r={...e,...this.inputs};let i=W(this.prompt,r);if(o?.warnUnused){const a=i.match(/\{\{(.*?)\}\}/g);if(a)throw n?.error.log(`Warning unused variables ${a.join(", ")}`),new Error(`Unused variables: ${a.join(", ")}`)}return i}getFormatInstructions(){let e="";for(const[s,n]of Object.entries(this.resFormat))switch(this.resFormat[s]){case T.String:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a string.`;break;case T.Number:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. the answer must be a number.`;break;case T.Boolean:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a true/false.`;break;case T.List:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a list of strings. Each string should be in a new line.`;break}return e}finalize(e,s){this.rawResponse=e;const n={},o=Object.keys(this.resFormat);if(o.length===0){if(e.trim()==="{}"||e.trim()==="")return{};throw new Error("Output format is empty, but rawValue is not an empty object representation or empty string.")}s=s||this.parseTaggedSections(e);for(const r of o){const i=r;let a;const u=s.tags[i];if(u)a=u;else throw new Error(`Expected results with tag ${i} but it does not exist`);const l=this.resFormat[r];try{const f=this.typeResponses(l,a);n[r]=f}catch(f){throw new Error(`Cannot convert value of key ${i} to ${l}: ${f.message}`)}}return this._result=n,n}parseTaggedSections(e){const s=/<(\w+)>(.*?)<\/\1>/gs,n={};let o=e;return o=o.replace(s,(r,i,a)=>(n[i]=a,"")),{tags:n,remaining:o.trim()}}typeResponses(e,s){let n;switch(e){case T.String:n=s;break;case T.Number:if(n=parseFloat(s),isNaN(n))throw new Error(`Cannot parse '${s}' as number. Expected a numeric string.`);break;case T.Boolean:const o=s.toLowerCase();if(o==="true")n=!0;else if(o==="false")n=!1;else throw new Error(`Cannot parse '${s}' as boolean. Expected 'true' or 'false'.`);break;case T.List:s===""?n=[]:n=s.split(`
`).map(r=>r.trim()).filter(r=>r.length>0);break}return n}}class R extends V{static{c(this,"Instruct")}constructor(e,s){super(e,s)}static with(e,s){return s?new R(e,s):new R(e,j)}}function P(t){return Array.isArray(t)?t:[t]}c(P,"arrayify");function $(t,e){return e?`${e}:${t.slice(0,8)}`:t.slice(0,8)}c($,"friendly");function ct(t){return new Promise(e=>setTimeout(e,t))}c(ct,"delay");const ut={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class lt{static{c(this,"BraveSearchTool")}name="brave";schema=ut;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:s}=e;this.apiKey=e["api-key"],this.throttle=s?1100/s:void 0}async execute(e,s={}){const{searchTerm:n}=e,{recorder:o}=s;if(o?.debug?.heading.log(`Brave: searching for ${n}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await ct(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const r=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",a=new URL(i);a.searchParams.append("q",n),a.searchParams.append("format","json");const u=await fetch(a.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":r}});if(!u.ok)throw new Error(`[Brave] HTTP error ${u.status}: ${u.statusText}`);return await u.json()}catch(r){throw o?.error.log("[Brave] Error fetching search results:",r),r}}}const ft=new lt,pt={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},dt={name:"calculator",schema:pt,execute:c(async t=>{const{operation:e,a:s,b:n}=t;switch(e){case"add":return`${s} + ${n} = ${s+n}`;case"subtract":return`${s} - ${n} = ${s-n}`;case"multiply":return`${s} * ${n} = ${s*n}`;case"divide":if(n===0)throw new Error("Cannot divide by zero");return`${s} / ${n} = ${s/n}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class gt{static{c(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let F;function ee(){return F||(F=new gt,F.register(dt),F.register(ft)),F}c(ee,"getToolRegistry");const ht={async convert(t,e){const{recorder:s,toolNames:n}=e,{message:o,system:r,replace:i}=t;let a;t.output?a=R.with(o,t.output):a=R.with(o),r&&(a.system=r);const u=[...new Set([...n??[],...t.tools??[]])];for(const l of u){const f=ee().get(l);a.addTool(f)}if(i){for(const l of i)if(l.source==="file"){const f=P(l.files),p=await tt(f,s);a.addInput(l.pattern,p)}}return a}};class mt{static{c(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}class q{static{c(this,"WriteOutputTask")}constructor(e,s=["response"]){this.output=e,this.keys=s}type="write-to-disk"}const yt={async convert(t){if(t.keys){const e=P(t.keys);return new q(t.output,e)}return new q(t.output)}},G=new mt;G.register("write-to-disk",yt),G.register("chat",ht);async function I(t,e){const{recorder:s}=e,n=t.tools??void 0,o=t.steps.map(async r=>(r.uses,await G.get(r.uses).convert(r,{recorder:s,toolNames:n})));return Promise.all(o)}c(I,"configToTasks");async function te(t,e){const{batch:s}=t;return s.length===1?se(s[0]):new it(s.map(n=>se(n)))}c(te,"configToPlanner");function se(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(n=>wt(n))),new ot(t.source,t.bind,e)}}c(se,"batchOptionsToPlanner");function wt(t){switch(t.type){case"file-exist":return new at(t.pattern)}}c(wt,"skipOptionsToSkipConditions");function vt(t){return t.success===!1&&t.error!==void 0}c(vt,"isErrorResult");function D(t,e){return{response:t,stats:e,success:!0}}c(D,"createResult");function N(t,e,s){return{response:e,stats:s,error:t,success:!1}}c(N,"createErrorResult");class kt{static{c(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}class bt{static{c(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:n,options:o={},recorder:r}=e,i=s.output,a=s.keys??[];if(o?.warnUnused){const f=a.filter(p=>!(p in n));f.length>0&&r?.warn?.log(`[Write To Disk] The following keys were not found in the variables: ${f.join(", ")}`)}let u="";if(a.length===1?u=n[a[0]]??"<not found>":u=a.map(f=>`[${f}]:
${n[f]??"<not found>"}
`).join(`
`),o?.dryRun){r?.info?.log("[Dry run] Write to Disk is not executed.");return}let l="";i.includes("*")?l=st(i,n.file):l=W(i,n,"{}"),await rt({filePath:l,content:u})}}var U=(t=>(t.LastResult="lastResult",t))(U||{});function $t(t,e,s){const{options:n,recorder:o}=s,r=n?.warnUnused??!0;for(const[i,a]of Object.entries(t))r&&e[i]&&o?.warn?.log(`Warning: Variable "${i}" is being overwritten. Previous value: ${e[i]}, new value: ${a}`),e[i]=a}c($t,"setResultsIntoVariables");class xt{static{c(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...n}=e;await Tt({instruct:s,...n})}}async function Tt(t){const{instruct:e,chat:s,provider:n,stats:o,variables:r,options:i,recorder:a}=t;if(e.system&&s.addSystem(e.system),s.addUser(e.compile(r,{recorder:a,options:i})),e.hasTools()){const l=Ct(e.tools);s.setToolSchemas(l)}if(i?.dryRun)return a?.debug?.log(s),{action:"complete"};let u=!0;for(;u;){const f=await n.createChatCompletionRequest(s).execute({recorder:a});if(o.in+=f.usage.in,o.out+=f.usage.out,f.type==="error")throw new Error(f.error.message);if(f.type==="success")switch(f.reason){case g.Stop:{if(f.message.content){const p=f.message.content;s.addAssistant(p);const d=e.finalize(p);$t(d,r,{options:i,recorder:a}),r[U.LastResult]=d}return u=!1,{action:"continue"}}case g.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case g.FunctionCall:{let p=f.message;if(f.message&&s.addAssistant(p.content,p.toolCalls),p.toolCalls&&p.toolCalls.length>0){const d=await Et(p.toolCalls,e,{recorder:a});a?.debug?.log(d),s.addTools(d),u=!0}else u=!1;break}}if(f.type!=="success")throw a?.debug?.log(f),new Error("Unexpected response type")}return{action:"continue"}}c(Tt,"executeChatAction");async function Et(t,e,s={}){const{recorder:n}=s,o=[];for(const r of t)o.push(new Promise((i,a)=>{const u=e.tools[r.name];if(!u){a(`Tool not found: ${r.name}`);return}n?.debug?.heading.log(`Executing tool ${u.name}`);let l={};try{l=typeof r.arguments=="string"?JSON.parse(r.arguments):r.arguments}catch{a(`argument for tool ${r.name} is not valid: ${JSON.stringify(r.arguments)}`)}u.execute(l).then(f=>{n?.debug?.log(`Complete tool ${u.name}: ${r.id}`),i({id:r.id,name:r.name,content:JSON.stringify(f)})}).catch(a)}));return Promise.all(o)}c(Et,"executeToolCalls");function Ct(t){const e=[];for(const[s,n]of Object.entries(t))e.push(n.schema);return e}c(Ct,"getToolSchemas");class At{static{c(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,n=s.type,o=this.getHandler(s);if(!o)throw new Error(`No handler registered for action type: ${n}`);if(!o.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${n}`);await o.execute(e)}}function St(){const t=new At;return t.register(new xt),t}c(St,"createBaseRegistry");function _t(){const t=St();return t.register(new bt),t}c(_t,"createNodeRegistry");const B=c((t,...e)=>{const s=c(async o=>{const{recorder:r}=o;let i=[];return"steps"in t?i=await I(t,{recorder:r}):i=[t,...e],i},"prepare");return{execute:c(async o=>{const{provider:r,variables:i,options:a,stats:u,recorder:l,name:f}=o,p=crypto.randomUUID(),d=_t();l?.info?.log({type:"task",id:p,status:w.Running,message:`[${$(p,f)}] Starting job`});try{const y=await s({recorder:l}),h=new kt;for(const[C,k]of y.entries()){l?.info?.log({type:"task",id:p,status:w.Running,message:`[${$(p,f)}] Processing step ${C+1}: ${k.type}`});try{await d.executeTask({task:k,chat:h,provider:r,variables:i,options:a,stats:u,recorder:l})}catch(x){throw x instanceof m?x:new H(`Error executing task ${k.type}`,{id:p,taskType:k.type,taskIndex:C,cause:x instanceof Error?x:new Error(String(x))})}}return l?.info?.log({type:"task",status:w.Success,id:p,message:`[${$(p,f)}] Completed ${y.length} steps`}),D(i[U.LastResult],u)}catch(y){const h=y instanceof m?y:new m("Serial workflow execution failed",{id:p,cause:y instanceof Error?y:new Error(String(y))});return l?.info?.log({type:"task",status:w.Fail,id:p,message:`[${$(p,f)}] Failed: ${h.message}`}),l?.error.log(h),N(h,i[U.LastResult],u)}},"execute")}},"serialWorkflow"),ne=c((t,...e)=>{const s=c(async o=>{const{recorder:r}=o;let i=[],a=null;if("batch"in t){const u=t;a=await te(u),i=await I(u,{recorder:r})}else a=t,i=[...e];return[a,i]},"prepare");return{execute:c(async o=>{const{provider:r,variables:i,options:a,stats:u,recorder:l,name:f}=o,p=crypto.randomUUID();try{const[d,y]=await s({recorder:l}),h=await d.plan(y);if(l?.debug?.heading.log("Runs",h),h.length===0)return l?.info?.log("No runs to execute"),D([],u);let C=0;l?.info?.log({type:"task",status:w.Running,id:p,message:`[${$(p,"CRW")}] Working on 0/${h.length}`});const k=c(async(E,L)=>{try{return await B(...E.tasks).execute({provider:r,variables:{...E.variables,...i},options:a,stats:u,recorder:l,name:`${f}-${L}`})}catch(A){const J=A instanceof m?A:new m("Error executing run",{cause:A instanceof Error?A:new Error(String(A))});return l?.error?.log(J),N(J,null,u)}finally{C++,l?.info?.log({type:"task",status:w.Running,id:p,message:`[${$(p,"CRW")}] Working on ${C}/${h.length}`})}},"executeRun"),x=5;let _=[];for(let E=0;E<h.length;E+=x){const L=h.slice(E,E+x),A=await Promise.all(L.map(k));_=_.concat(A)}const S=_.some(vt);l?.info?.log({type:"task",status:S?w.PartialSuccess:w.Success,id:p,message:`[${$(p,"CRW")}] All jobs (${h.length}) completed${S?" with some errors":""}`});const O=_.map(E=>E.response);return D(O,u)}catch(d){const y=d instanceof m?d:new m("Concurrent workflow execution failed",{id:p,cause:d instanceof Error?d:new Error(String(d))});return l?.error?.log(y),N(y,null,u)}},"execute")}},"concurrentWorkflow");class Rt{static{c(this,"DAGParser")}static parse(e){const s=new Map;for(const[o,r]of Object.entries(e)){const i=this.parseNodeDefinition(o,r);s.set(o,i)}return this.validateDependencies(s),this.checkForCycles(s),{stages:this.createExecutionStages(s),nodes:s}}static parseNodeDefinition(e,s){if(this.isSimpleTask(s))return{id:e,tasks:Array.isArray(s)?s:[s],dependencies:[],executionType:"serial"};if(this.isConcurrentNodeDefinition(s)){const i=s,a=i.dependsOn?P(i.dependsOn):[];return{id:e,tasks:i.tasks,dependencies:a,planner:i.planner,executionType:"concurrent"}}const n=s,o=n.dependsOn?P(n.dependsOn):[],r=P(n.task);return{id:e,tasks:r,dependencies:o,executionType:"serial"}}static isSimpleTask(e){return e.type||Array.isArray(e)}static isConcurrentNodeDefinition(e){return e&&typeof e=="object"&&"planner"in e}static validateDependencies(e){for(const s of e.values())for(const n of s.dependencies)if(!e.has(n))throw new m(`Node "${s.id}" depends on non-existent node "${n}"`)}static checkForCycles(e){const s=new Set,n=new Set,o=c(r=>{if(n.has(r))return!0;if(s.has(r))return!1;s.add(r),n.add(r);const i=e.get(r);for(const a of i.dependencies)if(o(a))return!0;return n.delete(r),!1},"hasCycle");for(const r of e.keys())if(o(r))throw new m(`Circular dependency detected involving node "${r}"`)}static createExecutionStages(e){const s=[],n=new Set,o=new Set(e.keys());for(;o.size>0;){const r=[];for(const i of o)e.get(i).dependencies.every(l=>n.has(l))&&r.push(i);if(r.length===0)throw new m("Unable to resolve DAG dependencies - possible circular reference");s.push(r),r.forEach(i=>{n.add(i),o.delete(i)})}return s}}class Ot{static{c(this,"DAGJobToDefinition")}static async convert(e,s){const{recorder:n}=s,o={};for(const[r,i]of Object.entries(e)){const{dependsOn:a,...u}=i;if("batch"in u){const l=u,f=await te(l),p=await I(l,{recorder:n}),d={planner:f,tasks:p,...a?{dependsOn:a}:{}};o[r]=d}else{const l=await I(u,{recorder:n});if(a){const f={task:l,dependsOn:a};o[r]=f}else o[r]=l}}return o}}async function Pt(t,e,s,n={}){const{variables:o}=s,r=e.nodes.get(t);try{let i;if(r.executionType==="concurrent"&&r.planner?i=await ne(r.planner,...r.tasks).execute({...s,variables:o,name:t}):i=await B(...r.tasks).execute({...s,variables:o,name:t}),!i.success)throw new m(`Node "${t}" failed: ${i.error?.message}`);return i.response}catch(i){if(!n.continueOnError)throw i;return null}}c(Pt,"executeNode");const Ft=c((t,e={})=>{const s=c(async(o,r)=>{const{recorder:i}=r,a={value:""};return Y(o,a)?await Ot.convert(o,r):(i?.warn?.log(a),o)},"prepare");return{execute:c(async o=>{const{stats:r,recorder:i}=o,{maxConcurrency:a=3}=e,u=crypto.randomUUID();try{const l=await s(t,{recorder:i});i?.debug?.log(l);const f=Rt.parse(l),p=new Map;i?.info?.log({type:"task",id:u,status:w.Running,message:`[${$(u)}] Starting workflow execution with ${f.stages.length} stages`});for(const[y,h]of f.stages.entries()){i?.info?.log({type:"task",id:u,status:w.Running,message:`[${$(u)}] Stage ${y+1}/${f.stages.length}, executing ${h.length} nodes: ${h.join(", ")}`});const C=Math.min(h.length,a);for(let k=0;k<h.length;k+=C){const x=h.slice(k,k+C);(await Promise.all(x.map(async S=>{const O=await Pt(S,f,o,e);return{nodeId:S,result:O}}))).forEach(({nodeId:S,result:O})=>{p.set(S,O)})}}i?.info?.log({type:"task",status:w.Success,id:u,message:`[${$(u)}] Workflow execution completed successfully`});const d=Object.fromEntries(p);return D(d,r)}catch(l){const f=l instanceof m?l:new m("DAG workflow execution failed",{id:u,cause:l instanceof Error?l:new Error(String(l))});return i?.info?.log({type:"task",status:w.Fail,id:u,message:`[${$(u)}] Workflow execution failed: ${f.message}`}),i?.error?.log(f),N(f,null,r)}},"execute")}},"dagWorkflow");export{m as A,j as D,R as I,b as L,Be as R,w as T,q as W,V as a,ee as b,ne as c,Ft as d,Ge as g,He as i,et as l,B as s};
