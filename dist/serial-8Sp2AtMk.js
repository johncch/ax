var H=Object.defineProperty;var a=(s,e)=>H(s,"name",{value:e,configurable:!0});import B from"@anthropic-ai/sdk";import W from"openai";import{serializeError as J}from"serialize-error";import{readFile as K,access as z,constants as G}from"fs/promises";import{glob as R}from"glob";import{readFile as v,writeFile as X,access as Q,mkdir as Y}from"node:fs/promises";import{resolve as A,dirname as Z}from"node:path";class w extends Error{static{a(this,"AxleError")}code;id;details;constructor(e,t){super(e,{cause:t?.cause}),this.name=this.constructor.name,this.code=t?.code||"AXLE_ERROR",this.id=t?.id,this.details=t?.details,Object.setPrototypeOf(this,w.prototype)}}var p=(s=>(s[s.Stop=0]="Stop",s[s.Length=1]="Length",s[s.FunctionCall=2]="FunctionCall",s[s.Error=3]="Error",s))(p||{});const V={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},ee=V.CLAUDE_3_5_HAIKU_LATEST;class te{static{a(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,t){this.model=t??ee,this.client=new B({apiKey:e})}createChatCompletionRequest(e){return new se(this,e)}}class se{static{a(this,"AnthropicChatRequest")}constructor(e,t){this.provider=e,this.chat=t}async execute(e){const{recorder:t}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toAnthropic(),max_tokens:re(o)};t?.debug?.log(n);let i;try{const c=await r.messages.create(n);i=ne(c)}catch(c){i={type:"error",error:{type:c.error.error.type??"Undetermined",message:c.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:c}}return t?.debug?.log(i),i}}function re(s){switch(s){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}a(re,"getMaxTokens");function U(s){switch(s){case"max_tokens":return p.Length;case"end_turn":return p.Stop;case"stop_sequence":return p.Stop;case"tool_use":return p.FunctionCall;default:return p.Error}}a(U,"getStopReason$1");function ne(s){const e=U(s.stop_reason);if(e===p.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:s.usage.input_tokens,out:s.usage.output_tokens},raw:s};if(e===p.FunctionCall){const t=s.content[0],r=t.type==="text"?t.text:"",o=s.content.slice(1).map(n=>{if(n.type==="tool_use")return{id:n.id,name:n.name,arguments:n.input}}).filter(n=>n!==null);return{type:"success",id:s.id,model:s.model,reason:p.FunctionCall,message:{role:s.role,content:r,toolCalls:o},usage:{in:s.usage.input_tokens,out:s.usage.output_tokens},raw:s}}if(s.type=="message"){const t=s.content[0];if(t.type=="text")return{type:"success",id:s.id,model:s.model,reason:U(s.stop_reason),message:{role:s.role,content:t.text},usage:{in:s.usage.input_tokens,out:s.usage.output_tokens},raw:s}}}a(ne,"translate$1");const oe="http://localhost:11434";class ae{static{a(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,t){this.url=t||oe,this.model=e}createChatCompletionRequest(e){return new ie(this.url,this.model,e)}}class ie{static{a(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,t,r){this.url=e,this.model=t,this.chat=r}async execute(e){const{recorder:t}=e,r={model:this.model,messages:this.chat.toOpenAI().messages,stream:!1,options:{temperature:.7}};t?.debug?.log(r);let o;try{const n=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const i=await n.json();o={type:"success",id:`ollama-${Date.now()}`,model:this.model,reason:p.Stop,message:{role:"assistant",content:i.message?.content||""},usage:{in:i.prompt_eval_count||0,out:i.eval_count||0},raw:i}}catch(n){t?.error?.log("Error fetching Ollama response:",n),o={type:"error",error:{type:"OllamaError",message:n.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(n)}}return t?.debug?.log(o),o}}const ce={GPT_4_1:"gpt-4.1"},ue=ce.GPT_4_1;class le{static{a(this,"OpenAIProvider")}constructor(e,t){this.apiKey=e,this.model=t||ue,this.client=new W({apiKey:e})}name="OpenAI";client;model;createChatCompletionRequest(e){return new he(this,e)}}class he{static{a(this,"OpenAIChatCompletionRequest")}constructor(e,t){this.provider=e,this.chat=t}async execute(e){const{recorder:t}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toOpenAI()};t?.debug?.log(n);let i;try{const c=await r.chat.completions.create(n);i=de(c)}catch(c){t?.error?.log(c),i={type:"error",error:{type:c.type??"Undetermined",message:c.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:c}}return t?.debug?.log(i),i}}function pe(s){switch(s){case"length":return p.Length;case"stop":return p.Stop;case"tool_calls":return p.FunctionCall;default:return p.Error}}a(pe,"getStopReason");function de(s){if(s.choices.length>0){const e=s.choices[0],t=e.message.tool_calls?.map(r=>({id:r.id,name:r.function.name,arguments:r.function.arguments}));return{type:"success",id:s.id,model:s.model,reason:pe(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:t},usage:{in:s.usage?.prompt_tokens??0,out:s.usage?.completion_tokens??0},raw:s}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:s.usage?.prompt_tokens??0,out:s.usage?.completion_tokens??0},raw:s}}a(de,"translate");function me(s,e){switch(s){case"openai":return new le(e["api-key"],e.model);case"anthropic":return new te(e["api-key"],e.model);case"ollama":{const t=e;return new ae(t.model,t.url)}default:throw new w("The provider is unsupported")}}a(me,"getProvider");class O extends w{static{a(this,"TaskError")}constructor(e,t){super(e,{code:"TASK_ERROR",id:t?.id,details:{taskType:t?.taskType,taskIndex:t?.taskIndex,...t?.details},cause:t?.cause}),Object.setPrototypeOf(this,O.prototype)}}const x={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var f=(s=>(s[s.Trace=10]="Trace",s[s.Debug=20]="Debug",s[s.Info=30]="Info",s[s.Warn=40]="Warn",s[s.Error=50]="Error",s[s.Fatal=60]="Fatal",s))(f||{});class fe{static{a(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=f.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=f.Debug>=this.currentLevel?this.createLoggingFunction(f.Debug):null,this._info=f.Info>=this.currentLevel?this.createLoggingFunction(f.Info):null,this._warn=f.Warn>=this.currentLevel?this.createLoggingFunction(f.Warn):null,this._error=this.createLoggingFunction(f.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const t=this.writers.indexOf(e);t!==-1&&this.writers.splice(t,1)}publish(e){this.logs.push(e);for(const t of this.writers)t.handleEvent(e)}logFunction(e,t,...r){let o=r.map(n=>typeof n=="string"?{message:n}:n instanceof Error?J(n):n);this.publish({level:e,time:Date.now(),kind:t,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=f.Info){return this.logs.filter(t=>t.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}class ge{static{a(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,t){this.messages.push({role:"assistant",content:e,toolCalls:t})}addTools(e){this.messages.push({role:"tool",content:e})}toOpenAI(){const e=[];this.system&&e.push({role:"system",content:this.system});const t=this.tools.length>0?this.tools.map(o=>({type:"function",function:o})):void 0,r=this.messages.map(o=>{switch(o.role){case"tool":return o.content.map(n=>({role:"tool",tool_call_id:n.id,content:n.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(n=>({id:n.id,type:"function",function:{name:n.name,arguments:JSON.stringify(n.arguments)}}))};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...r],...t&&{tools:t}}}toAnthropic(){const e=this.messages.map(r=>{switch(r.role){case"assistant":const o=[];return o.push({type:"text",text:r.content}),r.toolCalls&&o.push(...r.toolCalls.map(n=>({type:"tool_use",id:n.id,name:n.name,input:n.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:r.content.map(n=>({type:"tool_result",tool_use_id:n.id,content:n.content}))};default:return{role:"user",content:r.content}}}),t=this.tools.map(r=>({name:r.name,description:r.description,input_schema:r.parameters}));return{system:this.system,messages:e,tools:t}}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}async function ye({path:s,defaults:e,loader:t="File"}){let r=null,o="";if(s)try{o=A(s),r=await v(o,{encoding:"utf-8"})}catch{throw new Error(`${t} not found, see --help for details`)}else{for(const n of e.formats)try{o=A(e.name+"."+n),r=await v(o,{encoding:"utf-8"});break}catch{continue}if(r===null)throw new Error(`${t} not found, see --help for details`)}return{content:r,format:o.split(".").pop()??""}}a(ye,"loadFile");async function we(s,e){let t="";for(const r of s){const o=await R(r);e?.debug?.log(`many-files parser. For glob "${r}", found ${o.length} files.`);const n=await Promise.all(o.map(async i=>{const c=await v(i,"utf-8");return i+`:
`+c}));t+=n.join(`
`)}return t}a(we,"loadManyFiles");function be(s,e){s=s.replace("**/*","**");const t=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,r=s.match(t);if(r){let o="";return r.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,r.groups?.extension?o+=r.groups.extension:o+=e.ext,s.replace(r[0],o)}return s}a(be,"replaceFilePattern");function ke(s){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,t=s.match(e);return t&&t.length>0&&t.groups?{abs:s,dir:s.replace(t[0],""),ext:t.groups.extension,stem:t.groups.name,name:t[0]}:null}a(ke,"pathToComponents");async function P(s){const e=Z(s);try{await Q(e)}catch{await Y(e),await P(e)}}a(P,"ensureDirectoryExistence");async function Te({filePath:s,content:e}){await P(s),await X(s,e)}a(Te,"writeFileWithDirectories");class xe{static{a(this,"FileRunPlanner")}constructor(e,t,r=[]){this.source=e,this.bind=t,this.skipConditions=r}async plan(e){const t=[],r=await R(this.source,{withFileTypes:!0});for(const o of r){const n=o.fullpath(),i=ke(n);let c=!1;for(const u of this.skipConditions)if(c=await u.eval({components:i}),c)break;if(!c){const u=await K(n,"utf-8"),h={variables:{[this.bind]:u,...i},tasks:e};t.push(h)}}return t}}class Ee{static{a(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const t=this.planners.map(async o=>await o.plan(e));return(await Promise.all(t)).flat()}}function S(s,e,t="{{}}"){const r=t==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return s=s.replace(r,(o,n)=>e[n]?e[n]:o),s}a(S,"replaceVariables");class $e{static{a(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const t=S(this.pattern,e.components,"{}");try{return await z(t,G.F_OK),!0}catch{return!1}}}var g=(s=>(s.String="string",s.List="string[]",s.Number="number",s.Boolean="boolean",s))(g||{});const D={response:g.String};class L{static{a(this,"AbstractInstruct")}type="instruct";_result=void 0;prompt;system=null;inputs={};tools={};resFormat;rawResponse;finalPrompt;constructor(e,t){this.prompt=e,this.resFormat=t}setInputs(e){this.inputs=e}addInput(e,t){this.inputs[e]=t}addTools(e){for(const t of e)this.tools[t.name]=t}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}get result(){return this._result}compile(e,t={}){const r=this.getFinalUserPrompt(e,t),o=this.getFormatInstructions();return r+`
`+o}getFinalUserPrompt(e,t={}){const{recorder:r,options:o}=t,n={...e,...this.inputs};let i=S(this.prompt,n);if(o?.warnUnused){const c=i.match(/\{\{(.*?)\}\}/g);if(c)throw r?.error.log(`Warning unused variables ${c.join(", ")}`),new Error(`Unused variables: ${c.join(", ")}`)}return i}getFormatInstructions(){let e="";for(const[t,r]of Object.entries(this.resFormat))switch(this.resFormat[t]){case g.String:e+=`
Use <${t}></${t}> to indicate the answer for ${t}. The answer must be a string.`;break;case g.Number:e+=`
Use <${t}></${t}> to indicate the answer for ${t}. the answer must be a number.`;break;case g.Boolean:e+=`
Use <${t}></${t}> to indicate the answer for ${t}. The answer must be a true/false.`;break;case g.List:e+=`
Use <${t}></${t}> to indicate the answer for ${t}. The answer must be a list of strings. Each string should be in a new line.`;break}return e}finalize(e,t){this.rawResponse=e;const r={},o=Object.keys(this.resFormat);if(o.length===0){if(e.trim()==="{}"||e.trim()==="")return{};throw new Error("Output format is empty, but rawValue is not an empty object representation or empty string.")}t=t||this.parseTaggedSections(e);for(const n of o){const i=n;let c;const u=t.tags[i];if(u)c=u;else throw new Error(`Expected results with tag ${i} but it does not exist`);const h=this.resFormat[n];try{const l=this.typeResponses(h,c);r[n]=l}catch(l){throw new Error(`Cannot convert value of key ${i} to ${h}: ${l.message}`)}}return this._result=r,r}parseTaggedSections(e){const t=/<(\w+)>(.*?)<\/\1>/gs,r={};let o=e;return o=o.replace(t,(n,i,c)=>(r[i]=c,"")),{tags:r,remaining:o.trim()}}typeResponses(e,t){let r;switch(e){case g.String:r=t;break;case g.Number:if(r=parseFloat(t),isNaN(r))throw new Error(`Cannot parse '${t}' as number. Expected a numeric string.`);break;case g.Boolean:const o=t.toLowerCase();if(o==="true")r=!0;else if(o==="false")r=!1;else throw new Error(`Cannot parse '${t}' as boolean. Expected 'true' or 'false'.`);break;case g.List:t===""?r=[]:r=t.split(`
`).map(n=>n.trim()).filter(n=>n.length>0);break}return r}}class $ extends L{static{a(this,"Instruct")}constructor(e,t){super(e,t)}static with(e,t){return t?new $(e,t):new $(e,D)}}function _e(s){return Array.isArray(s)?s:[s]}a(_e,"arrayify");function C(s){return s.slice(0,8)}a(C,"friendly");function Ce(s){return new Promise(e=>setTimeout(e,s))}a(Ce,"delay");const ve={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class Se{static{a(this,"BraveSearchTool")}name="brave";schema=ve;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:t}=e;this.apiKey=e["api-key"],this.throttle=t?1100/t:void 0}async execute(e,t={}){const{searchTerm:r}=e,{recorder:o}=t;if(o?.debug?.heading.log(`Brave: searching for ${r}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await Ce(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const n=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",c=new URL(i);c.searchParams.append("q",r),c.searchParams.append("format","json");const u=await fetch(c.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":n}});if(!u.ok)throw new Error(`[Brave] HTTP error ${u.status}: ${u.statusText}`);return await u.json()}catch(n){throw o?.error.log("[Brave] Error fetching search results:",n),n}}}const Fe=new Se,Oe={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Re={name:"calculator",schema:Oe,execute:a(async s=>{const{operation:e,a:t,b:r}=s;switch(e){case"add":return`${t} + ${r} = ${t+r}`;case"subtract":return`${t} - ${r} = ${t-r}`;case"multiply":return`${t} * ${r} = ${t*r}`;case"divide":if(r===0)throw new Error("Cannot divide by zero");return`${t} / ${r} = ${t/r}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class Ae{static{a(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const t=this.executables[e];if(!t)throw new Error(`Tool '${e}' is not registered`);return t.setConfig?.(this.config[e]),t}}let E;function I(){return E||(E=new Ae,E.register(Re),E.register(Fe)),E}a(I,"getToolRegistry");const Ue={async convert(s,e){const{recorder:t,toolNames:r}=e,{message:o,system:n,replace:i}=s,c=$.with(o);n&&(c.system=n);const u=[...new Set([...r??[],...s.tools??[]])];for(const h of u){const l=I().get(h);c.addTool(l)}if(i){for(const h of i)if(h.source==="file"){const l=_e(h.files),m=await we(l,t);c.addInput(h.pattern,m)}}return c}};class Pe{static{a(this,"StepToClassRegistry")}converters=new Map;get(e){const t=this.converters.get(e);if(!t)throw new Error(`No converter registered for step: ${e}`);return t}register(e,t){this.converters.set(e,t)}}const De={async convert(s){return{type:"write-to-disk",output:s.output}}},F=new Pe;F.register("write-to-disk",De),F.register("chat",Ue);async function j(s,e){const{recorder:t}=e,r=s.tools??void 0,o=s.steps.map(async n=>(n.uses,await F.get(n.uses).convert(n,{recorder:t,toolNames:r})));return Promise.all(o)}a(j,"configToTasks");async function Le(s,e){const{batch:t}=s;return t.length===1?N(t[0]):new Ee(t.map(r=>N(r)))}a(Le,"configToPlanner");function N(s){switch(s.type){case"files":let e;return s["skip-if"]&&(e=s["skip-if"].map(r=>Ie(r))),new xe(s.source,s.bind,e)}}a(N,"batchOptionsToPlanner");function Ie(s){switch(s.type){case"file-exist":return new $e(s.pattern)}}a(Ie,"skipOptionsToSkipConditions");var k=(s=>(s.Latest="latest",s.LastResult="lastResult",s))(k||{});class je{static{a(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:t,variables:r,options:o={},recorder:n}=e;if(o.dryRun){n?.debug?.log("Dry run: no action was taken");return}const i=t.output,c=r[k.Latest];if(typeof c=="string"){let u="";i.includes("*")?u=be(i,r.file):u=S(i,r,"{}"),await Te({filePath:u,content:c})}}}class Ne{static{a(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:t,...r}=e;await qe({instruct:t,...r})}}async function qe(s){const{instruct:e,chat:t,provider:r,stats:o,variables:n,options:i,recorder:c}=s;if(e.system&&t.addSystem(e.system),t.addUser(e.compile(n,{recorder:c,options:i})),e.hasTools()){const h=He(e.tools);t.setToolSchemas(h)}if(i?.dryRun)return c?.debug?.log(t),{action:"complete"};let u=!0;for(;u;){const l=await r.createChatCompletionRequest(t).execute({recorder:c});if(o.in+=l.usage.in,o.out+=l.usage.out,l.type==="error")throw new Error(l.error.message);if(l.type==="success")switch(l.reason){case p.Stop:{if(l.message.content){const m=l.message.content;t.addAssistant(m);const d=e.finalize(m);for(const[y,b]of Object.entries(d))n[y]=b;n[k.LastResult]=d,n[k.Latest]=l.message.content}return u=!1,{action:"continue"}}case p.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case p.FunctionCall:{let m=l.message;if(l.message&&(t.addAssistant(m.content,m.toolCalls),n[k.Latest]=l.message.content),m.toolCalls&&m.toolCalls.length>0){const d=await Me(m.toolCalls,e);c?.debug?.log(d);const y=d.map(b=>({id:b.id,content:JSON.stringify(b.results)}));t.addTools(y),u=!0}else u=!1;break}}if(l.type!=="success")throw c?.debug?.log(l),new Error("Unexpected response type")}return{action:"continue"}}a(qe,"executeChatAction");async function Me(s,e){const t=[];for(const r of s)t.push(new Promise((o,n)=>{const i=e.tools[r.name];if(!i){n(`Tool not found: ${r.name}`);return}let c={};try{const u=JSON.parse(r.arguments);u&&typeof u=="object"&&!Array.isArray(u)&&(c=u)}catch{n(`argument for tool ${r.name} is not valid: ${JSON.stringify(r.arguments)}`)}i.execute(c).then(u=>o({id:r.id,results:u})).catch(n)}));return Promise.all(t)}a(Me,"executeToolCalls");function He(s){const e=[];for(const[t,r]of Object.entries(s))e.push(r.schema);return e}a(He,"getToolSchemas");class Be{static{a(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:t}=e,r=t.type,o=this.getHandler(t);if(!o)throw new Error(`No handler registered for action type: ${r}`);if(!o.canHandle(t))throw new Error(`Handler found but action does not match expected format: ${r}`);await o.execute(e)}}function We(){const s=new Be;return s.register(new Ne),s}a(We,"createBaseRegistry");function Je(){const s=We();return s.register(new je),s}a(Je,"createNodeRegistry");function Ke(s){return s.success===!1&&s.error!==void 0}a(Ke,"isErrorResult");function q(s,e){return{response:s,stats:e,success:!0}}a(q,"createResult");function M(s,e,t){return{response:e,stats:t,error:s,success:!1}}a(M,"createErrorResult");const ze=a((s,...e)=>{const t=a(async o=>{const{recorder:n}=o;let i=[];return"type"in s&&s.type==="serial"?i=await j(s,{recorder:n}):i=[s,...e],i},"prepare");return{execute:a(async o=>{const{provider:n,variables:i,options:c,stats:u,recorder:h}=o,l=crypto.randomUUID(),m=Je();h?.info?.log({type:"task",id:l,status:x.Running,message:`[${C(l)}] Starting job`});try{const d=await t({recorder:h}),y=new ge;for(const[b,_]of d.entries()){h?.info?.log({type:"task",id:l,status:x.Running,message:`[${C(l)}] Processing step ${b+1}: ${_.type}`});try{await m.executeTask({task:_,chat:y,provider:n,variables:i,options:c,stats:u,recorder:h})}catch(T){throw T instanceof w?T:new O(`Error executing task ${_.type}`,{id:l,taskType:_.type,taskIndex:b,cause:T instanceof Error?T:new Error(String(T))})}}return h?.info?.log({type:"task",status:x.Success,id:l,message:`[${C(l)}] Completed ${d.length} steps`}),q(i[k.LastResult],u)}catch(d){const y=d instanceof w?d:new w("Serial workflow execution failed",{id:l,cause:d instanceof Error?d:new Error(String(d))});return h?.info?.log({type:"task",status:x.Fail,id:l,message:`[${C(l)}] Failed: ${y.message}`}),h?.error.log(y),M(y,i[k.LastResult],u)}},"execute")}},"serialWorkflow");export{w as A,D,$ as I,f as L,fe as R,x as T,L as a,M as b,q as c,Le as d,j as e,I as f,me as g,Ke as i,ye as l,ze as s};
