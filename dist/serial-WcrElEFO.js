var G=Object.defineProperty;var c=(t,e)=>G(t,"name",{value:e,configurable:!0});import B from"@anthropic-ai/sdk";import{GoogleGenAI as W,Type as J,FinishReason as g}from"@google/genai";import K from"openai";import{serializeError as z}from"serialize-error";import{readFile as X,access as Y,constants as V}from"fs/promises";import{glob as O}from"glob";import{readFile as R,writeFile as Q,access as Z,mkdir as ee}from"node:fs/promises";import{resolve as A,dirname as te}from"node:path";class w extends Error{static{c(this,"AxleError")}code;id;details;constructor(e,s){super(e,{cause:s?.cause}),this.name=this.constructor.name,this.code=s?.code||"AXLE_ERROR",this.id=s?.id,this.details=s?.details,Object.setPrototypeOf(this,w.prototype)}}var d=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(d||{});const se={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},re=se.CLAUDE_3_5_HAIKU_LATEST;class ne{static{c(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,s){this.model=s??re,this.client=new B({apiKey:e})}createChatCompletionRequest(e){return new oe(this,e)}}class oe{static{c(this,"AnthropicChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...ie(this.chat),max_tokens:ae(o)};s?.debug?.log(n);let a;try{const i=await r.messages.create(n);a=ce(i)}catch(i){a={type:"error",error:{type:i.error.error.type??"Undetermined",message:i.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:i}}return s?.debug?.log(a),a}}function ae(t){switch(t){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}c(ae,"getMaxTokens");function P(t){switch(t){case"max_tokens":return d.Length;case"end_turn":return d.Stop;case"stop_sequence":return d.Stop;case"tool_use":return d.FunctionCall;default:return d.Error}}c(P,"getStopReason$2");function ie(t){const e=t.messages.map(r=>{switch(r.role){case"assistant":const o=[];return o.push({type:"text",text:r.content}),r.toolCalls&&o.push(...r.toolCalls.map(n=>({type:"tool_use",id:n.id,name:n.name,input:n.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:r.content.map(n=>({type:"tool_result",tool_use_id:n.id,content:n.content}))};default:return{role:"user",content:r.content}}}),s=t.tools.map(r=>({name:r.name,description:r.description,input_schema:r.parameters}));return{system:t.system,messages:e,tools:s}}c(ie,"prepareRequest$2");function ce(t){const e=P(t.stop_reason);if(e===d.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===d.FunctionCall){const s=t.content[0],r=s.type==="text"?s.text:"",o=t.content.slice(1).map(n=>{if(n.type==="tool_use")return{id:n.id,name:n.name,arguments:n.input}}).filter(n=>n!==null);return{type:"success",id:t.id,model:t.model,reason:d.FunctionCall,message:{role:t.role,content:r,toolCalls:o},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:P(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}c(ce,"translate");const le={GEMINI_2_5_FLASH_PREVIEW:"gemini-2.5-flash-preview-05-20"},ue=le.GEMINI_2_5_FLASH_PREVIEW;class pe{static{c(this,"GoogleAIProvider")}name="GoogleAI";client;model;constructor(e,s){this.model=s??ue,this.client=new W({apiKey:e})}createChatCompletionRequest(e){return new de(this,e)}}class de{static{c(this,"GoogleAIChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n=this.prepareRequest(this.chat);s?.debug?.log(n);let a;try{const i=await r.models.generateContent({model:o,...n});a=he(i,e)}catch(i){s?.error?.log(i),a={type:"error",error:{type:i.name??"Undetermined",message:i.message??"Unexpected error from Google AI"},usage:{in:0,out:0},raw:i}}return s?.debug?.log(a),a}prepareRequest(e){let s;e.messages.length===1&&e.messages[0].role=="user"?s=e.messages[0].content:s=e.messages.map(o=>{if(o.role==="user")return{role:"user",parts:[{text:o.content}]};if(o.role==="assistant"){const n={role:"assistant",parts:[]};return o.content&&n.parts.push({text:o.content}),o.toolCalls&&(n.parts=n.parts.concat(o.toolCalls.map(a=>{let i;return typeof a.arguments=="string"?i=JSON.parse(a.arguments):i=a.arguments,{functionCall:{id:a.id??void 0,name:a.name,args:i}}}))),n}else if(o.role==="tool")return{role:"user",parts:o.content.map(n=>({functionResponse:{id:n.id??void 0,name:n.name,response:{output:n.content}}}))}});const r={};return e.system&&(r.systemInstruction=e.system),e.tools.length>0&&(r.tools=e.tools.map(o=>({functionDeclarations:[{name:o.name,description:o.description,parameters:{...o.parameters,type:J.OBJECT}}]}))),{contents:s,config:r}}}function he(t,e){const{recorder:s}=e,r=t.usageMetadata.promptTokenCount,o=t.usageMetadata.totalTokenCount-r,n={in:r,out:o};if(!t)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};if(t.promptFeedback&&t.promptFeedback.blockReason)return{type:"error",error:{type:"Blocked",message:`Response blocked by Google AI: ${t.promptFeedback.blockReason}, ${t.promptFeedback.blockReasonMessage}`},usage:n,raw:t};if(!t.candidates||t.candidates.length===0)return{type:"error",error:{type:"InvalidResponse",message:"Invalid or empty response from Google AI"},usage:{in:0,out:0},raw:t};t.candidates.length>1&&s?.warn?.log(`We received ${t.candidates.length} response candidates`);const a=t.candidates[0],u=(a.content?.parts||[]).map(h=>h.text).filter(h=>h!==void 0).join(""),[p,l]=me(a.finishReason);if(p){let h;return t.functionCalls&&(h=t.functionCalls.map(m=>({id:m.id,name:m.name,arguments:JSON.stringify(m.args)}))),{type:"success",id:t.responseId,model:t.modelVersion,reason:t.functionCalls?d.FunctionCall:l,message:{role:"assistant",...u?{content:u}:{},...h?{toolCalls:h}:{}},usage:n,raw:t}}else return{type:"error",error:{type:"Undetermined",message:`Unexpected stop reason: ${l}`},usage:n,raw:t}}c(he,"translateResponse$2");function me(t){switch(t){case g.STOP:return[!0,d.Stop];case g.MAX_TOKENS:return[!0,d.Length];case g.FINISH_REASON_UNSPECIFIED:case g.SAFETY:case g.RECITATION:case g.LANGUAGE:case g.OTHER:case g.BLOCKLIST:case g.PROHIBITED_CONTENT:case g.SPII:case g.MALFORMED_FUNCTION_CALL:case g.IMAGE_SAFETY:return[!1,d.Error]}}c(me,"getStopReason$1");const ge="http://localhost:11434";class fe{static{c(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,s){this.url=s||ge,this.model=e}createChatCompletionRequest(e){return new ye(this.url,this.model,e)}}class ye{static{c(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,s,r){this.url=e,this.model=s,this.chat=r}async execute(e){const{recorder:s}=e,r={model:this.model,stream:!1,options:{temperature:.7},...we(this.chat)};s?.debug?.log(r);let o;try{const n=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!n.ok)throw console.log(n),new Error(`HTTP error! status: ${n.status}`);const a=await n.json();o=be(a)}catch(n){s?.error?.log("Error fetching Ollama response:",n),o={type:"error",error:{type:"OllamaError",message:n.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(n)}}return s?.debug?.log(o),o}}function we(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,r=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(n=>({role:"tool",tool_call_id:n.id,content:n.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(n=>{const a=n.id;return{type:"function",function:{name:n.name,arguments:n.arguments},...a&&{id:a}}})};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...r],...s&&{tools:s}}}c(we,"prepareRequest$1");function be(t){if(t.done_reason==="stop"&&t.message){const e=t.message.content,s=[];if(t.message.tool_calls)for(const o of t.message.tool_calls)s.push({id:o.id,name:o.function.name,arguments:o.function.arguments});const r=s.length>0;return{type:"success",id:`ollama-${Date.now()}`,model:t.model,reason:r?d.FunctionCall:d.Stop,message:{role:"assistant",content:e,...r&&{toolCalls:s}},usage:{in:t.prompt_eval_count||0,out:t.eval_count||0},raw:t}}return{type:"error",error:{type:"OllamaError",message:"Unexpected error from Ollama"},usage:{in:0,out:0},raw:t}}c(be,"translateResponse$1");const ke={GPT_4_1:"gpt-4.1"},Te=ke.GPT_4_1;class Ee{static{c(this,"OpenAIProvider")}constructor(e,s){this.apiKey=e,this.model=s||Te,this.client=new K({apiKey:e})}name="OpenAI";client;model;createChatCompletionRequest(e){return new _e(this,e)}}class _e{static{c(this,"OpenAIChatCompletionRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...xe(this.chat)};s?.debug?.log(n);let a;try{const i=await r.chat.completions.create(n);a=$e(i)}catch(i){s?.error?.log(i),a={type:"error",error:{type:i.type??"Undetermined",message:i.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:i}}return s?.debug?.log(a),a}}function Ce(t){switch(t){case"length":return d.Length;case"stop":return d.Stop;case"tool_calls":return d.FunctionCall;default:return d.Error}}c(Ce,"getStopReason");function xe(t){const e=[];t.system&&e.push({role:"system",content:t.system});const s=t.tools.length>0?t.tools.map(o=>({type:"function",function:o})):void 0,r=t.messages.map(o=>{switch(o.role){case"tool":return o.content.map(n=>({role:"tool",tool_call_id:n.id,content:n.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(n=>{const a=n.id;return{type:"function",function:{name:n.name,arguments:typeof n.arguments=="string"?n.arguments:JSON.stringify(n.arguments)},...a&&{id:a}}})};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...r],...s&&{tools:s}}}c(xe,"prepareRequest");function $e(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(r=>({id:r.id,name:r.function.name,arguments:r.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:Ce(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}c($e,"translateResponse");function ve(t,e){if(!e||Object.keys(e).length===0)throw new w(`The provider ${t} is not configured. Please check your configuration.`);switch(t){case"openai":return new Ee(e["api-key"],e.model);case"anthropic":return new ne(e["api-key"],e.model);case"google":return new pe(e["api-key"],e.model);case"ollama":{const s=e;return new fe(s.model,s.url)}default:throw new w("The provider is unsupported")}}c(ve,"getProvider");class I extends w{static{c(this,"TaskError")}constructor(e,s){super(e,{code:"TASK_ERROR",id:s?.id,details:{taskType:s?.taskType,taskIndex:s?.taskIndex,...s?.details},cause:s?.cause}),Object.setPrototypeOf(this,I.prototype)}}const E={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var f=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(f||{});class Re{static{c(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=f.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=f.Debug>=this.currentLevel?this.createLoggingFunction(f.Debug):null,this._info=f.Info>=this.currentLevel?this.createLoggingFunction(f.Info):null,this._warn=f.Warn>=this.currentLevel?this.createLoggingFunction(f.Warn):null,this._error=this.createLoggingFunction(f.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s,...r){let o=r.map(n=>typeof n=="string"?{message:n}:n instanceof Error?z(n):n);this.publish({level:e,time:Date.now(),kind:s,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=f.Info){return this.logs.filter(s=>s.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}class Se{static{c(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}async function Fe({path:t,defaults:e,loader:s="File"}){let r=null,o="";if(t)try{o=A(t),r=await R(o,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const n of e.formats)try{o=A(e.name+"."+n),r=await R(o,{encoding:"utf-8"});break}catch{continue}if(r===null)throw new Error(`${s} not found, see --help for details`)}return{content:r,format:o.split(".").pop()??""}}c(Fe,"loadFile");async function Ie(t,e){let s="";for(const r of t){const o=await O(r);e?.debug?.log(`many-files parser. For glob "${r}", found ${o.length} files.`);const n=await Promise.all(o.map(async a=>{const i=await R(a,"utf-8");return a+`:
`+i}));s+=n.join(`
`)}return s}c(Ie,"loadManyFiles");function Oe(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,r=t.match(s);if(r){let o="";return r.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,r.groups?.extension?o+=r.groups.extension:o+=e.ext,t.replace(r[0],o)}return t}c(Oe,"replaceFilePattern");function Ae(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}c(Ae,"pathToComponents");async function U(t){const e=te(t);try{await Z(e)}catch{await ee(e),await U(e)}}c(U,"ensureDirectoryExistence");async function Pe({filePath:t,content:e}){await U(t),await Q(t,e)}c(Pe,"writeFileWithDirectories");class Ue{static{c(this,"FileRunPlanner")}constructor(e,s,r=[]){this.source=e,this.bind=s,this.skipConditions=r}async plan(e){const s=[],r=await O(this.source,{withFileTypes:!0});for(const o of r){const n=o.fullpath(),a=Ae(n);let i=!1;for(const u of this.skipConditions)if(i=await u.eval({components:a}),i)break;if(!i){const u=await X(n,"utf-8"),p={variables:{[this.bind]:u,...a},tasks:e};s.push(p)}}return s}}class Le{static{c(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async o=>await o.plan(e));return(await Promise.all(s)).flat()}}function S(t,e,s="{{}}"){const r=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(r,(o,n)=>e[n]?e[n]:o),t}c(S,"replaceVariables");class Ne{static{c(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=S(this.pattern,e.components,"{}");try{return await Y(s,V.F_OK),!0}catch{return!1}}}var y=(t=>(t.String="string",t.List="string[]",t.Number="number",t.Boolean="boolean",t))(y||{});const L={response:y.String};class N{static{c(this,"AbstractInstruct")}type="instruct";_result=void 0;prompt;system=null;inputs={};tools={};resFormat;rawResponse;finalPrompt;constructor(e,s){this.prompt=e,this.resFormat=s}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}get result(){return this._result}compile(e,s={}){const r=this.getFinalUserPrompt(e,s),o=this.getFormatInstructions();return r+`
`+o}getFinalUserPrompt(e,s={}){const{recorder:r,options:o}=s,n={...e,...this.inputs};let a=S(this.prompt,n);if(o?.warnUnused){const i=a.match(/\{\{(.*?)\}\}/g);if(i)throw r?.error.log(`Warning unused variables ${i.join(", ")}`),new Error(`Unused variables: ${i.join(", ")}`)}return a}getFormatInstructions(){let e="";for(const[s,r]of Object.entries(this.resFormat))switch(this.resFormat[s]){case y.String:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a string.`;break;case y.Number:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. the answer must be a number.`;break;case y.Boolean:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a true/false.`;break;case y.List:e+=`
Use <${s}></${s}> to indicate the answer for ${s}. The answer must be a list of strings. Each string should be in a new line.`;break}return e}finalize(e,s){this.rawResponse=e;const r={},o=Object.keys(this.resFormat);if(o.length===0){if(e.trim()==="{}"||e.trim()==="")return{};throw new Error("Output format is empty, but rawValue is not an empty object representation or empty string.")}s=s||this.parseTaggedSections(e);for(const n of o){const a=n;let i;const u=s.tags[a];if(u)i=u;else throw new Error(`Expected results with tag ${a} but it does not exist`);const p=this.resFormat[n];try{const l=this.typeResponses(p,i);r[n]=l}catch(l){throw new Error(`Cannot convert value of key ${a} to ${p}: ${l.message}`)}}return this._result=r,r}parseTaggedSections(e){const s=/<(\w+)>(.*?)<\/\1>/gs,r={};let o=e;return o=o.replace(s,(n,a,i)=>(r[a]=i,"")),{tags:r,remaining:o.trim()}}typeResponses(e,s){let r;switch(e){case y.String:r=s;break;case y.Number:if(r=parseFloat(s),isNaN(r))throw new Error(`Cannot parse '${s}' as number. Expected a numeric string.`);break;case y.Boolean:const o=s.toLowerCase();if(o==="true")r=!0;else if(o==="false")r=!1;else throw new Error(`Cannot parse '${s}' as boolean. Expected 'true' or 'false'.`);break;case y.List:s===""?r=[]:r=s.split(`
`).map(n=>n.trim()).filter(n=>n.length>0);break}return r}}class C extends N{static{c(this,"Instruct")}constructor(e,s){super(e,s)}static with(e,s){return s?new C(e,s):new C(e,L)}}function De(t){return Array.isArray(t)?t:[t]}c(De,"arrayify");function v(t){return t.slice(0,8)}c(v,"friendly");function Me(t){return new Promise(e=>setTimeout(e,t))}c(Me,"delay");const qe={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class je{static{c(this,"BraveSearchTool")}name="brave";schema=qe;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:s}=e;this.apiKey=e["api-key"],this.throttle=s?1100/s:void 0}async execute(e,s={}){const{searchTerm:r}=e,{recorder:o}=s;if(o?.debug?.heading.log(`Brave: searching for ${r}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await Me(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const n=this.apiKey,a="https://api.search.brave.com/res/v1/web/search",i=new URL(a);i.searchParams.append("q",r),i.searchParams.append("format","json");const u=await fetch(i.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":n}});if(!u.ok)throw new Error(`[Brave] HTTP error ${u.status}: ${u.statusText}`);return await u.json()}catch(n){throw o?.error.log("[Brave] Error fetching search results:",n),n}}}const He=new je,Ge={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Be={name:"calculator",schema:Ge,execute:c(async t=>{const{operation:e,a:s,b:r}=t;switch(e){case"add":return`${s} + ${r} = ${s+r}`;case"subtract":return`${s} - ${r} = ${s-r}`;case"multiply":return`${s} * ${r} = ${s*r}`;case"divide":if(r===0)throw new Error("Cannot divide by zero");return`${s} / ${r} = ${s/r}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class We{static{c(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let _;function D(){return _||(_=new We,_.register(Be),_.register(He)),_}c(D,"getToolRegistry");const Je={async convert(t,e){const{recorder:s,toolNames:r}=e,{message:o,system:n,replace:a}=t,i=C.with(o);n&&(i.system=n);const u=[...new Set([...r??[],...t.tools??[]])];for(const p of u){const l=D().get(p);i.addTool(l)}if(a){for(const p of a)if(p.source==="file"){const l=De(p.files),h=await Ie(l,s);i.addInput(p.pattern,h)}}return i}};class Ke{static{c(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}const ze={async convert(t){return{type:"write-to-disk",output:t.output}}},F=new Ke;F.register("write-to-disk",ze),F.register("chat",Je);async function M(t,e){const{recorder:s}=e,r=t.tools??void 0,o=t.steps.map(async n=>(n.uses,await F.get(n.uses).convert(n,{recorder:s,toolNames:r})));return Promise.all(o)}c(M,"configToTasks");async function Xe(t,e){const{batch:s}=t;return s.length===1?q(s[0]):new Le(s.map(r=>q(r)))}c(Xe,"configToPlanner");function q(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(r=>Ye(r))),new Ue(t.source,t.bind,e)}}c(q,"batchOptionsToPlanner");function Ye(t){switch(t.type){case"file-exist":return new Ne(t.pattern)}}c(Ye,"skipOptionsToSkipConditions");var k=(t=>(t.Latest="latest",t.LastResult="lastResult",t))(k||{});class Ve{static{c(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:r,options:o={},recorder:n}=e;if(o.dryRun){n?.debug?.log("Dry run: no action was taken");return}const a=s.output,i=r[k.Latest];if(typeof i=="string"){let u="";a.includes("*")?u=Oe(a,r.file):u=S(a,r,"{}"),await Pe({filePath:u,content:i})}}}class Qe{static{c(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...r}=e;await Ze({instruct:s,...r})}}async function Ze(t){const{instruct:e,chat:s,provider:r,stats:o,variables:n,options:a,recorder:i}=t;if(e.system&&s.addSystem(e.system),s.addUser(e.compile(n,{recorder:i,options:a})),e.hasTools()){const p=tt(e.tools);s.setToolSchemas(p)}if(a?.dryRun)return i?.debug?.log(s),{action:"complete"};let u=!0;for(;u;){const l=await r.createChatCompletionRequest(s).execute({recorder:i});if(o.in+=l.usage.in,o.out+=l.usage.out,l.type==="error")throw new Error(l.error.message);if(l.type==="success")switch(l.reason){case d.Stop:{if(l.message.content){const h=l.message.content;s.addAssistant(h);const m=e.finalize(h);for(const[b,x]of Object.entries(m))n[b]=x;n[k.LastResult]=m,n[k.Latest]=l.message.content}return u=!1,{action:"continue"}}case d.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case d.FunctionCall:{let h=l.message;if(l.message&&(s.addAssistant(h.content,h.toolCalls),n[k.Latest]=l.message.content),h.toolCalls&&h.toolCalls.length>0){const m=await et(h.toolCalls,e,{recorder:i});i?.debug?.log(m),s.addTools(m),u=!0}else u=!1;break}}if(l.type!=="success")throw i?.debug?.log(l),new Error("Unexpected response type")}return{action:"continue"}}c(Ze,"executeChatAction");async function et(t,e,s={}){const{recorder:r}=s,o=[];for(const n of t)o.push(new Promise((a,i)=>{const u=e.tools[n.name];if(!u){i(`Tool not found: ${n.name}`);return}r?.debug?.heading.log(`Executing tool ${u.name}`);let p={};try{p=typeof n.arguments=="string"?JSON.parse(n.arguments):n.arguments}catch{i(`argument for tool ${n.name} is not valid: ${JSON.stringify(n.arguments)}`)}u.execute(p).then(l=>{r?.debug?.log(`Complete tool ${u.name}: ${n.id}`),a({id:n.id,name:n.name,content:JSON.stringify(l)})}).catch(i)}));return Promise.all(o)}c(et,"executeToolCalls");function tt(t){const e=[];for(const[s,r]of Object.entries(t))e.push(r.schema);return e}c(tt,"getToolSchemas");class st{static{c(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,r=s.type,o=this.getHandler(s);if(!o)throw new Error(`No handler registered for action type: ${r}`);if(!o.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${r}`);await o.execute(e)}}function rt(){const t=new st;return t.register(new Qe),t}c(rt,"createBaseRegistry");function nt(){const t=rt();return t.register(new Ve),t}c(nt,"createNodeRegistry");function ot(t){return t.success===!1&&t.error!==void 0}c(ot,"isErrorResult");function j(t,e){return{response:t,stats:e,success:!0}}c(j,"createResult");function H(t,e,s){return{response:e,stats:s,error:t,success:!1}}c(H,"createErrorResult");const at=c((t,...e)=>{const s=c(async o=>{const{recorder:n}=o;let a=[];return"type"in t&&t.type==="serial"?a=await M(t,{recorder:n}):a=[t,...e],a},"prepare");return{execute:c(async o=>{const{provider:n,variables:a,options:i,stats:u,recorder:p}=o,l=crypto.randomUUID(),h=nt();p?.info?.log({type:"task",id:l,status:E.Running,message:`[${v(l)}] Starting job`});try{const m=await s({recorder:p}),b=new Se;for(const[x,$]of m.entries()){p?.info?.log({type:"task",id:l,status:E.Running,message:`[${v(l)}] Processing step ${x+1}: ${$.type}`});try{await h.executeTask({task:$,chat:b,provider:n,variables:a,options:i,stats:u,recorder:p})}catch(T){throw T instanceof w?T:new I(`Error executing task ${$.type}`,{id:l,taskType:$.type,taskIndex:x,cause:T instanceof Error?T:new Error(String(T))})}}return p?.info?.log({type:"task",status:E.Success,id:l,message:`[${v(l)}] Completed ${m.length} steps`}),j(a[k.LastResult],u)}catch(m){const b=m instanceof w?m:new w("Serial workflow execution failed",{id:l,cause:m instanceof Error?m:new Error(String(m))});return p?.info?.log({type:"task",status:E.Fail,id:l,message:`[${v(l)}] Failed: ${b.message}`}),p?.error.log(b),H(b,a[k.LastResult],u)}},"execute")}},"serialWorkflow");export{w as A,L as D,C as I,f as L,Re as R,E as T,N as a,H as b,j as c,Xe as d,M as e,D as f,ve as g,ot as i,Fe as l,at as s};
