var L=Object.defineProperty;var a=(t,e)=>L(t,"name",{value:e,configurable:!0});import N from"@anthropic-ai/sdk";import M from"openai";import{serializeError as H}from"serialize-error";import{readFile as K,access as W,constants as B}from"fs/promises";import{glob as F}from"glob";import{readFile as C,writeFile as J,access as z,mkdir as G}from"node:fs/promises";import{resolve as O,dirname as V}from"node:path";class g extends Error{static{a(this,"AxleError")}code;id;details;constructor(e,s){super(e,{cause:s?.cause}),this.name=this.constructor.name,this.code=s?.code||"AXLE_ERROR",this.id=s?.id,this.details=s?.details,Object.setPrototypeOf(this,g.prototype)}}var p=(t=>(t[t.Stop=0]="Stop",t[t.Length=1]="Length",t[t.FunctionCall=2]="FunctionCall",t[t.Error=3]="Error",t))(p||{});const X={CLAUDE_3_5_HAIKU_LATEST:"claude-3-5-haiku-latest"},Q=X.CLAUDE_3_5_HAIKU_LATEST;class Y{static{a(this,"AnthropicProvider")}name="Anthropic";client;model;constructor(e,s){this.model=s??Q,this.client=new N({apiKey:e})}createChatCompletionRequest(e){return new Z(this,e)}}class Z{static{a(this,"AnthropicChatRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toAnthropic(),max_tokens:ee(o)};s?.debug?.log(n);let i;try{const c=await r.messages.create(n);i=te(c)}catch(c){i={type:"error",error:{type:c.error.error.type??"Undetermined",message:c.error.error.message??"Unexpected error from Anthropic"},usage:{in:0,out:0},raw:c}}return s?.debug?.log(i),i}}function ee(t){switch(t){case"claude-3-5-sonnet-20240620":return 4096;case"claude-3-opus-20240229":return 4096;case"claude-3-sonnet-20240229":return 4096;case"claude-3-haiku-20240307":return 4096;default:return 4096}}a(ee,"getMaxTokens");function R(t){switch(t){case"max_tokens":return p.Length;case"end_turn":return p.Stop;case"stop_sequence":return p.Stop;case"tool_use":return p.FunctionCall;default:return p.Error}}a(R,"getStopReason$1");function te(t){const e=R(t.stop_reason);if(e===p.Error)return{type:"error",error:{type:"Uncaught error",message:"Stop reason is not recognized."},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t};if(e===p.FunctionCall){const s=t.content[0],r=s.type==="text"?s.text:"",o=t.content.slice(1).map(n=>{if(n.type==="tool_use")return{id:n.id,name:n.name,arguments:n.input}}).filter(n=>n!==null);return{type:"success",id:t.id,model:t.model,reason:p.FunctionCall,message:{role:t.role,content:r,toolCalls:o},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}if(t.type=="message"){const s=t.content[0];if(s.type=="text")return{type:"success",id:t.id,model:t.model,reason:R(t.stop_reason),message:{role:t.role,content:s.text},usage:{in:t.usage.input_tokens,out:t.usage.output_tokens},raw:t}}}a(te,"translate$1");const se="http://localhost:11434";class re{static{a(this,"OllamaProvider")}name="Ollama";url;model;recorder;constructor(e,s){this.url=s||se,this.model=e}createChatCompletionRequest(e){return new ne(this.url,this.model,e)}}class ne{static{a(this,"OllamaChatCompletionRequest")}chat;url;model;constructor(e,s,r){this.url=e,this.model=s,this.chat=r}async execute(e){const{recorder:s}=e,r={model:this.model,messages:this.chat.toOpenAI().messages,stream:!1,options:{temperature:.7}};s?.debug?.log(r);let o;try{const n=await fetch(`${this.url}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const i=await n.json();o={type:"success",id:`ollama-${Date.now()}`,model:this.model,reason:p.Stop,message:{role:"assistant",content:i.message?.content||""},usage:{in:i.prompt_eval_count||0,out:i.eval_count||0},raw:i}}catch(n){s?.error?.log("Error fetching Ollama response:",n),o={type:"error",error:{type:"OllamaError",message:n.message||"Unexpected error from Ollama"},usage:{in:0,out:0},raw:JSON.stringify(n)}}return s?.debug?.log(o),o}}const oe={GPT_4_1:"gpt-4.1"},ae=oe.GPT_4_1;class ie{static{a(this,"OpenAIProvider")}constructor(e,s){this.apiKey=e,this.model=s||ae,this.client=new M({apiKey:e})}name="OpenAI";client;model;createChatCompletionRequest(e){return new ce(this,e)}}class ce{static{a(this,"OpenAIChatCompletionRequest")}constructor(e,s){this.provider=e,this.chat=s}async execute(e){const{recorder:s}=e,{client:r,model:o}=this.provider,n={model:o,...this.chat.toOpenAI()};s?.debug?.log(n);let i;try{const c=await r.chat.completions.create(n);i=le(c)}catch(c){s?.error?.log(c),i={type:"error",error:{type:c.type??"Undetermined",message:c.message??"Unexpected error from OpenAI"},usage:{in:0,out:0},raw:c}}return s?.debug?.log(i),i}}function ue(t){switch(t){case"length":return p.Length;case"stop":return p.Stop;case"tool_calls":return p.FunctionCall;default:return p.Error}}a(ue,"getStopReason");function le(t){if(t.choices.length>0){const e=t.choices[0],s=e.message.tool_calls?.map(r=>({id:r.id,name:r.function.name,arguments:r.function.arguments}));return{type:"success",id:t.id,model:t.model,reason:ue(e.finish_reason),message:{content:e.message.content??"",role:e.message.role,toolCalls:s},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}return{type:"error",error:{type:"undetermined",message:"Unexpected response from OpenAI"},usage:{in:t.usage?.prompt_tokens??0,out:t.usage?.completion_tokens??0},raw:t}}a(le,"translate");function he(t,e){switch(t){case"openai":return new ie(e["api-key"],e.model);case"anthropic":return new Y(e["api-key"],e.model);case"ollama":{const s=e;return new re(s.model,s.url)}default:throw new g("The provider is unsupported")}}a(he,"getProvider");class S extends g{static{a(this,"TaskError")}constructor(e,s){super(e,{code:"TASK_ERROR",id:s?.id,details:{taskType:s?.taskType,taskIndex:s?.taskIndex,...s?.details},cause:s?.cause}),Object.setPrototypeOf(this,S.prototype)}}const k={Running:"running",Success:"success",PartialSuccess:"partialSuccess",Fail:"fail"};var m=(t=>(t[t.Trace=10]="Trace",t[t.Debug=20]="Debug",t[t.Info=30]="Info",t[t.Warn=40]="Warn",t[t.Error=50]="Error",t[t.Fatal=60]="Fatal",t))(m||{});class pe{static{a(this,"Recorder")}instanceId=crypto.randomUUID();currentLevel=m.Info;logs=[];writers=[];_debug;_info;_warn;_error;constructor(){this.buildMethods()}buildMethods(){this._debug=m.Debug>=this.currentLevel?this.createLoggingFunction(m.Debug):null,this._info=m.Info>=this.currentLevel?this.createLoggingFunction(m.Info):null,this._warn=m.Warn>=this.currentLevel?this.createLoggingFunction(m.Warn):null,this._error=this.createLoggingFunction(m.Error)}set level(e){this.currentLevel=e,this.buildMethods()}get level(){return this.currentLevel}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}get debug(){return this._debug}subscribe(e){this.writers.includes(e)||this.writers.push(e)}unsubscribe(e){const s=this.writers.indexOf(e);s!==-1&&this.writers.splice(s,1)}publish(e){this.logs.push(e);for(const s of this.writers)s.handleEvent(e)}logFunction(e,s,...r){let o=r.map(n=>typeof n=="string"?{message:n}:n instanceof Error?H(n):n);this.publish({level:e,time:Date.now(),kind:s,payload:o})}createLoggingFunction(e){return{log:this.logFunction.bind(this,e,"body"),heading:{log:this.logFunction.bind(this,e,"heading")}}}getLogs(e=m.Info){return this.logs.filter(s=>s.level>=e)}async shutdown(){for(const e of this.writers)typeof e.flush=="function"&&await e.flush()}}class de{static{a(this,"Chat")}system;messages=[];tools=[];setToolSchemas(e){this.tools=e}addSystem(e){this.system=e}addUser(e){this.messages.push({role:"user",content:e})}addAssistant(e,s){this.messages.push({role:"assistant",content:e,toolCalls:s})}addTools(e){this.messages.push({role:"tool",content:e})}toOpenAI(){const e=[];this.system&&e.push({role:"system",content:this.system});const s=this.tools.length>0?this.tools.map(o=>({type:"function",function:o})):void 0,r=this.messages.map(o=>{switch(o.role){case"tool":return o.content.map(n=>({role:"tool",tool_call_id:n.id,content:n.content}));case"assistant":return{role:o.role,content:o.content,tool_calls:o.toolCalls.map(n=>({id:n.id,type:"function",function:{name:n.name,arguments:JSON.stringify(n.arguments)}}))};default:return{role:o.role,content:o.content}}}).flat(1/0);return{messages:[...e,...r],...s&&{tools:s}}}toAnthropic(){const e=this.messages.map(r=>{switch(r.role){case"assistant":const o=[];return o.push({type:"text",text:r.content}),r.toolCalls&&o.push(...r.toolCalls.map(n=>({type:"tool_use",id:n.id,name:n.name,input:n.arguments}))),{role:"assistant",content:o};case"tool":return{role:"user",content:r.content.map(n=>({type:"tool_result",tool_use_id:n.id,content:n.content}))};default:return{role:"user",content:r.content}}}),s=this.tools.map(r=>({name:r.name,description:r.description,input_schema:r.parameters}));return{system:this.system,messages:e,tools:s}}toString(){return JSON.stringify({system:this.system,messages:this.messages,tools:this.tools})}}async function me({path:t,defaults:e,loader:s="File"}){let r=null,o="";if(t)try{o=O(t),r=await C(o,{encoding:"utf-8"})}catch{throw new Error(`${s} not found, see --help for details`)}else{for(const n of e.formats)try{o=O(e.name+"."+n),r=await C(o,{encoding:"utf-8"});break}catch{continue}if(r===null)throw new Error(`${s} not found, see --help for details`)}return{content:r,format:o.split(".").pop()??""}}a(me,"loadFile");async function fe(t,e){let s="";for(const r of t){const o=await F(r);e?.debug?.log(`many-files parser. For glob "${r}", found ${o.length} files.`);const n=await Promise.all(o.map(async i=>{const c=await C(i,"utf-8");return i+`:
`+c}));s+=n.join(`
`)}return s}a(fe,"loadManyFiles");function ge(t,e){t=t.replace("**/*","**");const s=/(?<asterisks>\*{1,2})(?<extension>\.[^\\/]+)?/,r=t.match(s);if(r){let o="";return r.groups?.asterisks.length==1?o+=e.stem:o+=e.dir+e.stem,r.groups?.extension?o+=r.groups.extension:o+=e.ext,t.replace(r[0],o)}return t}a(ge,"replaceFilePattern");function ye(t){const e=/(?<name>[^\\/]+)(?<extension>\.[^\\/]+)$/,s=t.match(e);return s&&s.length>0&&s.groups?{abs:t,dir:t.replace(s[0],""),ext:s.groups.extension,stem:s.groups.name,name:s[0]}:null}a(ye,"pathToComponents");async function A(t){const e=V(t);try{await z(e)}catch{await G(e),await A(e)}}a(A,"ensureDirectoryExistence");async function we({filePath:t,content:e}){await A(t),await J(t,e)}a(we,"writeFileWithDirectories");class be{static{a(this,"FileRunPlanner")}constructor(e,s,r=[]){this.source=e,this.bind=s,this.skipConditions=r}async plan(e){const s=[],r=await F(this.source,{withFileTypes:!0});for(const o of r){const n=o.fullpath(),i=ye(n);let c=!1;for(const u of this.skipConditions)if(c=await u.eval({components:i}),c)break;if(!c){const u=await K(n,"utf-8"),h={variables:{[this.bind]:u,...i},tasks:e};s.push(h)}}return s}}class Te{static{a(this,"MultiPlanner")}planners;constructor(e){this.planners=e}async plan(e){const s=this.planners.map(async o=>await o.plan(e));return(await Promise.all(s)).flat()}}function $(t,e,s="{{}}"){const r=s==="{{}}"?/\{\{(.*?)\}\}/g:/\{(.*?)\}/g;return t=t.replace(r,(o,n)=>e[n]?e[n]:o),t}a($,"replaceVariables");class ke{static{a(this,"FileExistSkipCondition")}constructor(e){this.pattern=e}type="file-exist";async eval(e){const s=$(this.pattern,e.components,"{}");try{return await W(s,B.F_OK),!0}catch{return!1}}}class P{static{a(this,"Instruct")}type="instruct";prompt;system=null;inputs;outputFormat;tools={};constructor(e,s={response:"string"}){this.prompt=e,this.outputFormat=s}setInputs(e){this.inputs=e}addInput(e,s){this.inputs[e]=s}addTools(e){for(const s of e)this.tools[s.name]=s}addTool(e){this.tools[e.name]=e}hasTools(){return Object.keys(this.tools).length>0}compile(e,s={}){const{recorder:r,options:o}=s,n={...e,...this.inputs};let i=$(this.prompt,n);if(o?.warnUnused){const c=i.match(/\{\{(.*?)\}\}/g);if(c)throw r.error.log(`Warning unused variables ${c.join(", ")}`),new Error(`Unused variables: ${c.join(", ")}`)}return i}}function xe(t){return Array.isArray(t)?t:[t]}a(xe,"arrayify");function E(t){return t.slice(0,8)}a(E,"friendly");function _e(t){return new Promise(e=>setTimeout(e,t))}a(_e,"delay");const Ee={name:"brave",description:"Perform a search using the Brave search engine",parameters:{type:"object",properties:{searchTerm:{type:"string",description:"The search term to query"}},required:["searchTerm"]}};class Ce{static{a(this,"BraveSearchTool")}name="brave";schema=Ee;apiKey;throttle;lastExecTime=0;constructor(e){e&&this.setConfig(e)}setConfig(e){const{rateLimit:s}=e;this.apiKey=e["api-key"],this.throttle=s?1100/s:void 0}async execute(e,s={}){const{searchTerm:r}=e,{recorder:o}=s;if(o?.debug?.heading.log(`Brave: searching for ${r}`),this.throttle){for(;Date.now()-this.lastExecTime<this.throttle;)await _e(this.throttle-(Date.now()-this.lastExecTime));this.lastExecTime=Date.now()}try{const n=this.apiKey,i="https://api.search.brave.com/res/v1/web/search",c=new URL(i);c.searchParams.append("q",r),c.searchParams.append("format","json");const u=await fetch(c.toString(),{method:"GET",headers:{Accept:"application/json","X-Subscription-Token":n}});if(!u.ok)throw new Error(`[Brave] HTTP error ${u.status}: ${u.statusText}`);return await u.json()}catch(n){throw o?.error.log("[Brave] Error fetching search results:",n),n}}}const $e=new Ce,ve={name:"calculator",description:"Performs basic arithmetic operations",parameters:{type:"object",properties:{operation:{type:"string",description:"The operation to perform (add, subtract, multiply, divide)",enum:["add","subtract","multiply","divide"]},a:{type:"number",description:"First operand"},b:{type:"number",description:"Second operand"}},required:["operation","a","b"]}},Se={name:"calculator",schema:ve,execute:a(async t=>{const{operation:e,a:s,b:r}=t;switch(e){case"add":return`${s} + ${r} = ${s+r}`;case"subtract":return`${s} - ${r} = ${s-r}`;case"multiply":return`${s} * ${r} = ${s*r}`;case"divide":if(r===0)throw new Error("Cannot divide by zero");return`${s} / ${r} = ${s/r}`;default:throw new Error(`Unknown operation: ${e}`)}},"execute")};class Fe{static{a(this,"ToolRegistry")}executables={};config;setConfig(e){this.config=e}register(e){if(this.executables[e.name])throw new Error(`Tool with name '${e.name}' is already registered`);this.executables[e.name]=e}get(e){const s=this.executables[e];if(!s)throw new Error(`Tool '${e}' is not registered`);return s.setConfig?.(this.config[e]),s}}let x;function D(){return x||(x=new Fe,x.register(Se),x.register($e)),x}a(D,"getToolRegistry");const Oe={async convert(t,e){const{recorder:s,toolNames:r}=e,{message:o,system:n,replace:i}=t,c=new P(o);n&&(c.system=n);const u=[...new Set([...r??[],...t.tools??[]])];for(const h of u){const l=D().get(h);c.addTool(l)}if(i){for(const h of i)if(h.source==="file"){const l=xe(h.files),f=await fe(l,s);c.addInput(h.pattern,f)}}return c}};class Re{static{a(this,"StepToClassRegistry")}converters=new Map;get(e){const s=this.converters.get(e);if(!s)throw new Error(`No converter registered for step: ${e}`);return s}register(e,s){this.converters.set(e,s)}}const Ae={async convert(t){return{type:"write-to-disk",output:t.output}}},v=new Re;v.register("write-to-disk",Ae),v.register("chat",Oe);async function I(t,e){const{recorder:s}=e,r=t.tools??void 0,o=t.steps.map(async n=>(n.uses,await v.get(n.uses).convert(n,{recorder:s,toolNames:r})));return Promise.all(o)}a(I,"configToTasks");async function Pe(t,e){const{batch:s}=t;return s.length===1?U(s[0]):new Te(s.map(r=>U(r)))}a(Pe,"configToPlanner");function U(t){switch(t.type){case"files":let e;return t["skip-if"]&&(e=t["skip-if"].map(r=>De(r))),new be(t.source,t.bind,e)}}a(U,"batchOptionsToPlanner");function De(t){switch(t.type){case"file-exist":return new ke(t.pattern)}}a(De,"skipOptionsToSkipConditions");var w=(t=>(t.Latest="latest",t))(w||{});class Ie{static{a(this,"WriteToDiskTaskHandler")}taskType="write-to-disk";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="write-to-disk"}async execute(e){const{task:s,variables:r,options:o={},recorder:n}=e;if(o.dryRun){n?.debug?.log("Dry run: no action was taken");return}const i=s.output,c=r[w.Latest];if(typeof c=="string"){let u="";i.includes("*")?u=ge(i,r.file):u=$(i,r,"{}"),await we({filePath:u,content:c})}}}class Ue{static{a(this,"ChatTaskHandler")}taskType="instruct";canHandle(e){return e&&typeof e=="object"&&"type"in e&&e.type==="instruct"}async execute(e){const{task:s,...r}=e;await je({instruct:s,...r})}}async function je(t){const{instruct:e,chat:s,provider:r,stats:o,variables:n,options:i,recorder:c}=t;if(e.system&&s.addSystem(e.system),s.addUser(e.compile(n,{recorder:c,options:i})),e.hasTools()){const h=Le(e.tools);s.setToolSchemas(h)}if(i?.dryRun)return c?.debug?.log(s),{action:"complete"};let u=!0;for(;u;){const l=await r.createChatCompletionRequest(s).execute({recorder:c});if(o.in+=l.usage.in,o.out+=l.usage.out,l.type==="error")throw new Error(l.error.message);if(l.type==="success")switch(l.reason){case p.Stop:return l.message.content&&(s.addAssistant(l.message.content),n[w.Latest]=l.message.content),u=!1,{action:"continue"};case p.Length:throw new Error("Incomplete model output due to `max_tokens` parameter or token limit");case p.FunctionCall:{let f=l.message;if(l.message&&(s.addAssistant(f.content,f.toolCalls),n[w.Latest]=l.message.content),f.toolCalls&&f.toolCalls.length>0){const d=await qe(f.toolCalls,e);c?.debug?.log(d);const y=d.map(b=>({id:b.id,content:JSON.stringify(b.results)}));s.addTools(y),u=!0}else u=!1;break}}if(l.type!=="success")throw c?.debug?.log(l),new Error("Unexpected response type")}return{action:"continue"}}a(je,"executeChatAction");async function qe(t,e){const s=[];for(const r of t)s.push(new Promise((o,n)=>{const i=e.tools[r.name];if(!i){n(`Tool not found: ${r.name}`);return}let c={};try{const u=JSON.parse(r.arguments);u&&typeof u=="object"&&!Array.isArray(u)&&(c=u)}catch{n(`argument for tool ${r.name} is not valid: ${JSON.stringify(r.arguments)}`)}i.execute(c).then(u=>o({id:r.id,results:u})).catch(n)}));return Promise.all(s)}a(qe,"executeToolCalls");function Le(t){const e=[];for(const[s,r]of Object.entries(t))e.push(r.schema);return e}a(Le,"getToolSchemas");class Ne{static{a(this,"TaskRegistry")}handlers=new Map;register(e){this.handlers.set(e.taskType,e)}getHandler(e){return this.handlers.get(e.type)}hasHandler(e){return this.handlers.has(e.type)}async executeTask(e){const{task:s}=e,r=s.type,o=this.getHandler(s);if(!o)throw new Error(`No handler registered for action type: ${r}`);if(!o.canHandle(s))throw new Error(`Handler found but action does not match expected format: ${r}`);await o.execute(e)}}function Me(){const t=new Ne;return t.register(new Ue),t}a(Me,"createBaseRegistry");function He(){const t=Me();return t.register(new Ie),t}a(He,"createNodeRegistry");function Ke(t){return t.success===!1&&t.error!==void 0}a(Ke,"isErrorResult");function j(t,e){return{response:t,stats:e,success:!0}}a(j,"createResult");function q(t,e,s){return{response:e,stats:s,error:t,success:!1}}a(q,"createErrorResult");const We=a((t,...e)=>{const s=a(async o=>{const{recorder:n}=o;let i=[];return"type"in t&&t.type==="serial"?i=await I(t,{recorder:n}):i=[t,...e],i},"prepare");return{execute:a(async o=>{const{provider:n,variables:i,options:c,stats:u,recorder:h}=o,l=crypto.randomUUID(),f=He();h?.info?.log({type:"task",id:l,status:k.Running,message:`[${E(l)}] Starting job`});try{const d=await s({recorder:h}),y=new de;for(const[b,_]of d.entries()){h?.info?.log({type:"task",id:l,status:k.Running,message:`[${E(l)}] Processing step ${b+1}: ${_.type}`});try{await f.executeTask({task:_,chat:y,provider:n,variables:i,options:c,stats:u,recorder:h})}catch(T){throw T instanceof g?T:new S(`Error executing task ${_.type}`,{id:l,taskType:_.type,taskIndex:b,cause:T instanceof Error?T:new Error(String(T))})}}return h?.info?.log({type:"task",status:k.Success,id:l,message:`[${E(l)}] Completed ${d.length} steps`}),j(i[w.Latest],u)}catch(d){const y=d instanceof g?d:new g("Serial workflow execution failed",{id:l,cause:d instanceof Error?d:new Error(String(d))});return h?.info?.log({type:"task",status:k.Fail,id:l,message:`[${E(l)}] Failed: ${y.message}`}),h?.error.log(y),q(y,i[w.Latest],u)}},"execute")}},"serialWorkflow");export{g as A,P as I,m as L,pe as R,k as T,q as a,Pe as b,j as c,I as d,D as e,he as g,Ke as i,me as l,We as s};
